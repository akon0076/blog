"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const rosSchema_1 = require("../schema/rosSchema");
class UnresolvedSchema {
    constructor(schema, errors = []) {
        this.schema = schema;
        this.errors = errors;
    }
}
exports.UnresolvedSchema = UnresolvedSchema;
class ResolvedSchema {
    constructor(schema, errors = []) {
        this.schema = schema;
        this.errors = errors;
    }
}
exports.ResolvedSchema = ResolvedSchema;
class JSONSchemaService {
    static getJSONSchemaService() {
        return JSONSchemaService.jsonSchemaService;
    }
    resolveSchemaContent(schemaToResolve) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolveErrors = schemaToResolve.errors.slice(0);
            const schema = schemaToResolve.schema;
            const findSection = (schema, path) => {
                if (!path) {
                    return schema;
                }
                let current = schema;
                if (path[0] === '/') {
                    path = path.substring(1);
                }
                path.split('/').some((part) => {
                    current = current[part];
                    return !current;
                });
                return current;
            };
            const resolveLink = (node, linkedSchema, linkPath) => {
                const section = findSection(linkedSchema, linkPath);
                if (section) {
                    for (const key in section) {
                        if (section.hasOwnProperty(key) && !node.hasOwnProperty(key)) {
                            node[key] = section[key];
                        }
                    }
                }
                else {
                    resolveErrors.push('json.schema.invalidref: ' +
                        `$ref '${linkPath}' in ${linkedSchema.id} can not be resolved.`);
                }
                delete node.$ref;
            };
            const resolveRefs = (node, parentSchema) => {
                if (!node) {
                    return;
                }
                const toWalk = [node];
                const seen = [];
                const collectEntries = (...entries) => {
                    for (const entry of entries) {
                        if (typeof entry === 'object') {
                            toWalk.push(entry);
                        }
                    }
                };
                const collectMapEntries = (...maps) => {
                    for (const map of maps) {
                        if (typeof map === 'object') {
                            for (const key in map) {
                                if (map.hasOwnProperty(key)) {
                                    const entry = map[key];
                                    toWalk.push(entry);
                                }
                            }
                        }
                    }
                };
                const collectArrayEntries = (...arrays) => {
                    for (const array of arrays) {
                        if (Array.isArray(array)) {
                            toWalk.push.apply(toWalk, array);
                        }
                    }
                };
                while (toWalk.length) {
                    const next = toWalk.pop();
                    if (!next) {
                        break;
                    }
                    if (seen.indexOf(next) >= 0) {
                        continue;
                    }
                    seen.push(next);
                    if (next.$ref) {
                        const segments = next.$ref.split('#', 2);
                        resolveLink(next, parentSchema, segments[1]);
                    }
                    collectEntries(next.items, next.additionalProperties, next.not);
                    collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);
                    collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);
                }
            };
            yield resolveRefs(schema, schema);
            return new ResolvedSchema(schema, resolveErrors);
        });
    }
    getSchemaForResource() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rosResolvedSchema) {
                return this.rosResolvedSchema;
            }
            const baseSchema = _.merge({}, rosSchema_1.rosSchema);
            const schemaBasePath = path.resolve(path.dirname(__dirname), 'schema');
            const rosSchemaFileNames = fs.readdirSync(path.join(schemaBasePath, 'ros'));
            for (const fileName of rosSchemaFileNames) {
                const resourceSchema = require(path.resolve(schemaBasePath, 'ros', fileName));
                if (resourceSchema.$id) {
                    baseSchema.definitions[resourceSchema.$id] = resourceSchema;
                    baseSchema.properties.Resources.patternProperties['^[a-zA-Z_][a-zA-Z.0-9_-]{0,127}$'].anyOf.push({
                        $ref: `#/definitions/${resourceSchema.$id}`
                    });
                }
            }
            this.rosResolvedSchema = yield this.resolveSchemaContent(new UnresolvedSchema(baseSchema, []));
            return this.rosResolvedSchema;
        });
    }
}
JSONSchemaService.jsonSchemaService = new JSONSchemaService();
exports.JSONSchemaService = JSONSchemaService;
