"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const astNode_1 = require("./astNode");
const jsonParser_1 = require("../parser/jsonParser");
class ObjectASTNode extends astNode_1.ASTNode {
    constructor(parent, start, end) {
        super(parent, 'object', start, end);
        this.properties = [];
    }
    getChildNodes() {
        return this.properties;
    }
    getValue() {
        const result = {};
        this.properties.forEach(p => {
            const v = p.value && p.value.getValue();
            if (typeof v !== undefined) {
                result[p.key.getValue()] = v;
            }
        });
        return result;
    }
    addProperty(node) {
        if (node) {
            this.properties.push(node);
            return true;
        }
        return false;
    }
    validate(schema, validationResult, matchingSchemas) {
        if (schema.type === 'string' &&
            this.properties.length === 1 &&
            this.properties[0].customTag) {
            return;
        }
        super.validate(schema, validationResult, matchingSchemas);
        const seenKeys = Object.create(null);
        const unprocessedProperties = [];
        this.properties.forEach(node => {
            const key = node.key.value;
            if (!node.value) {
                return;
            }
            seenKeys[key] = node.value;
            unprocessedProperties.push(key);
        });
        const propertyProcessed = (prop) => {
            let index = unprocessedProperties.indexOf(prop);
            while (index >= 0) {
                unprocessedProperties.splice(index, 1);
                index = unprocessedProperties.indexOf(prop);
            }
        };
        if (Array.isArray(schema.required)) {
            schema.required.forEach((propertyName) => {
                if (!seenKeys[propertyName]) {
                    const key = this.parent &&
                        this.parent.key;
                    const location = key
                        ? { start: key.start, end: key.end }
                        : { start: this.start, end: this.start + 1 };
                    validationResult.problems.push({
                        location,
                        severity: jsonParser_1.ProblemSeverity.Error,
                        code: jsonParser_1.ErrorCode.PropertyRequired,
                        message: 'Missing property ' +
                            propertyName,
                        path: this.getPath(),
                    });
                }
            });
        }
        if (schema.properties) {
            Object.keys(schema.properties).forEach((propertyName) => {
                propertyProcessed(propertyName);
                const prop = schema.properties && schema.properties[propertyName];
                const child = seenKeys[propertyName];
                if (child) {
                    const propertyValidationResult = new jsonParser_1.ValidationResult();
                    child.validate(prop, propertyValidationResult, matchingSchemas);
                    validationResult.mergePropertyMatch(propertyValidationResult);
                }
            });
        }
        if (schema.patternProperties) {
            Object.keys(schema.patternProperties).forEach((propertyPattern) => {
                const regex = new RegExp(propertyPattern);
                unprocessedProperties
                    .slice(0)
                    .forEach((propertyName) => {
                    if (regex.test(propertyName)) {
                        propertyProcessed(propertyName);
                        const child = seenKeys[propertyName];
                        if (child) {
                            const propertyValidationResult = new jsonParser_1.ValidationResult();
                            child.validate(schema.patternProperties[propertyPattern], propertyValidationResult, matchingSchemas);
                            validationResult.mergePropertyMatch(propertyValidationResult);
                        }
                    }
                });
            });
        }
        if (schema.additionalProperties === false) {
            if (unprocessedProperties.length > 0) {
                unprocessedProperties.forEach((propertyName) => {
                    const child = seenKeys[propertyName];
                    if (child) {
                        let propertyNode = null;
                        if (child.type !== 'property') {
                            propertyNode = child.parent;
                            if (propertyNode.type === 'object') {
                                propertyNode = propertyNode.properties[0];
                            }
                        }
                        else {
                            propertyNode = child;
                        }
                        validationResult.problems.push({
                            location: {
                                start: propertyNode.key.start,
                                end: propertyNode.key.end,
                            },
                            severity: jsonParser_1.ProblemSeverity.Error,
                            code: jsonParser_1.ErrorCode.AdditionalProperty,
                            message: 'Unexpected property ' +
                                propertyName,
                            path: this.getPath(),
                        });
                    }
                });
            }
        }
    }
}
exports.ObjectASTNode = ObjectASTNode;
