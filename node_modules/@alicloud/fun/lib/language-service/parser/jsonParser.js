"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["Undefined"] = 0] = "Undefined";
    ErrorCode[ErrorCode["TypeError"] = 1] = "TypeError";
    ErrorCode[ErrorCode["EnumValueMismatch"] = 2] = "EnumValueMismatch";
    ErrorCode[ErrorCode["PropertyRequired"] = 3] = "PropertyRequired";
    ErrorCode[ErrorCode["AdditionalProperty"] = 4] = "AdditionalProperty";
    ErrorCode[ErrorCode["MaxOneMatch"] = 5] = "MaxOneMatch";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
exports.ErrorCodeTable = {
    [ErrorCode.TypeError]: 'type',
    [ErrorCode.EnumValueMismatch]: 'value',
    [ErrorCode.PropertyRequired]: 'required',
    [ErrorCode.AdditionalProperty]: 'additional',
    [ErrorCode.MaxOneMatch]: 'one',
};
var ProblemSeverity;
(function (ProblemSeverity) {
    ProblemSeverity[ProblemSeverity["Error"] = 0] = "Error";
    ProblemSeverity[ProblemSeverity["Warning"] = 1] = "Warning";
})(ProblemSeverity = exports.ProblemSeverity || (exports.ProblemSeverity = {}));
class SchemaCollector {
    constructor() {
        this.schemas = [];
    }
    add(schema) {
        this.schemas.push(schema);
    }
    merge(other) {
        this.schemas.push(...other.schemas);
    }
    newSub() {
        return new SchemaCollector();
    }
}
exports.SchemaCollector = SchemaCollector;
class ValidationResult {
    constructor() {
        this.problems = [];
        this.propertiesMatches = 0;
        this.propertiesValueMatches = 0;
        this.primaryValueMatches = 0;
        this.enumValueMatch = false;
        this.enumValues = [];
        this.warnings = [];
        this.errors = [];
    }
    hasProblems() {
        return !!this.problems.length;
    }
    mergeAll(validationResults) {
        validationResults.forEach(validationResult => {
            this.merge(validationResult);
        });
    }
    merge(validationResult) {
        this.problems = this.problems.concat(validationResult.problems);
    }
    mergeEnumValues(validationResult) {
        // 如果当前的 validationResult 以及传递进来的 validationResult
        // 都没有匹配上 enum 值
        // 并且两者都有存在的 Enum 值
        // 那么修改当前的 validationResult 中针对 Enum 不匹配的报错提示信息（结合两者的 Enum 列表）
        if (!this.enumValueMatch &&
            !validationResult.enumValueMatch &&
            this.enumValues && this.enumValues.length > 0 &&
            validationResult.enumValues && validationResult.enumValues.length > 0) {
            this.enumValues = this.enumValues.concat(validationResult.enumValues);
            for (const error of this.problems) {
                if (error.code === ErrorCode.EnumValueMismatch) {
                    error.message =
                        'enumWarning: ' +
                            'Value is not accepted. Valid values:' +
                            this.enumValues.map(v => JSON.stringify(v)).join(', ');
                }
            }
        }
    }
    mergePropertyMatch(propertyValidationResult) {
        this.merge(propertyValidationResult);
        this.propertiesMatches++;
        // 如果子元素的验证结果匹配了 Enum
        // 或当前元素验证无问题并且子元素有其子元素的属性验证信息
        // 记为当前元素的属性值验证 + 1
        if (propertyValidationResult.enumValueMatch ||
            (!this.hasProblems() && propertyValidationResult.propertiesMatches)) {
            this.propertiesValueMatches++;
        }
        // 如果子元素有 Enum 匹配并且 Enum 的可选值只有一个
        // 记为当前验证结果有一次 主值 匹配
        if (propertyValidationResult.enumValueMatch &&
            propertyValidationResult.enumValues &&
            propertyValidationResult.enumValues.length === 1) {
            this.primaryValueMatches++;
        }
    }
    compareGeneric(other) {
        if (this.hasProblems() !== other.hasProblems()) {
            return this.hasProblems() ? -1 : 1;
        }
        if (this.enumValueMatch !== other.enumValueMatch) {
            return other.enumValueMatch ? -1 : 1;
        }
        if (this.propertiesValueMatches !== other.propertiesValueMatches) {
            return this.propertiesValueMatches - other.propertiesValueMatches;
        }
        if (this.primaryValueMatches !== other.primaryValueMatches) {
            return this.primaryValueMatches - other.primaryValueMatches;
        }
        return this.propertiesMatches - other.propertiesMatches;
    }
}
exports.ValidationResult = ValidationResult;
