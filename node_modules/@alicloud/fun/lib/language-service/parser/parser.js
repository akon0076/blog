"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Yaml = __importStar(require("yaml-ast-parser"));
const nullASTNode_1 = require("../model/nullASTNode");
const objectASTNode_1 = require("../model/objectASTNode");
const propertyASTNode_1 = require("../model/propertyASTNode");
const stringASTNode_1 = require("../model/stringASTNode");
const arrayASTNode_1 = require("../model/arrayASTNode");
const booleanASTNode_1 = require("../model/booleanASTNode");
const numberASTNode_1 = require("../model/numberASTNode");
const customTag_1 = require("../model/customTag");
/**
 * 判断该节点的跨度是否包含偏移量
 * 如果包含，判断该节点的所有后代是否符合条件，并返回该节点
 * 在判断后代的过程中，如果某个后代符合条件，则将其放入收集器中
 * @param node
 * @param collector
 * @param offset
 */
function findNode(node, collector, offset) {
    if (offset >= node.start && offset <= node.end) {
        const children = node.getChildNodes();
        for (const child of children) {
            if (child.start > offset) { // 初步的筛选，如果 start 大于 offset，肯定不符合条件
                continue;
            }
            const item = findNode(child, collector, offset);
            if (item) {
                collector.push(item); // 后代符合条件，放入收集器中
            }
        }
        return node;
    }
}
/**
 * 根据指定的偏移量在 AST 树中找到跨度最小的节点
 * 算法思路：
 * 获取根节点及其后代跨度范围包含偏移量的所有节点
 * 比较符合条件的所有节点，取出跨度最小的节点
 * @param root
 * @param offset
 */
function getNodeFromOffset(root, offset) {
    const collector = [];
    const foundNode = findNode(root, collector, offset);
    let curMinDist = Number.MAX_VALUE;
    let curMinNode = null;
    collector.forEach(node => {
        const dist = node.end - node.start;
        if (dist < curMinDist) {
            curMinDist = dist;
            curMinNode = node;
        }
    });
    return curMinNode || foundNode;
}
exports.getNodeFromOffset = getNodeFromOffset;
function buildAstRecursively(parent, node) {
    if (!node) {
        return new nullASTNode_1.NullASTNode(parent, 0, 0);
    }
    switch (node.kind) {
        case Yaml.Kind.MAP: {
            const instance = node;
            const result = new objectASTNode_1.ObjectASTNode(parent, instance.startPosition, instance.endPosition);
            for (const mapping of instance.mappings) {
                result.addProperty(buildAstRecursively(result, mapping));
            }
            return result;
        }
        case Yaml.Kind.MAPPING: {
            const instance = node;
            const key = instance.key;
            const keyNode = new stringASTNode_1.StringASTNode(parent, true, key.value, key.startPosition, key.endPosition);
            const customTag = customTag_1.CUSTOM_TAGS_BY_PROPERTY_NAME[key.value];
            const result = new propertyASTNode_1.PropertyASTNode(parent, keyNode, keyNode.start, instance.endPosition, customTag);
            const valueNode = instance.value
                ? buildAstRecursively(result, instance.value)
                : new nullASTNode_1.NullASTNode(result, instance.endPosition, instance.endPosition);
            result.setValue(valueNode);
            return result;
        }
        case Yaml.Kind.SEQ: {
            const instance = node;
            const result = new arrayASTNode_1.ArrayASTNode(parent, instance.startPosition, instance.endPosition);
            for (const item of instance.items) {
                const itemNode = item === null
                    ? new nullASTNode_1.NullASTNode(parent, instance.endPosition, instance.endPosition)
                    : buildAstRecursively(result, item);
                result.addItem(itemNode);
            }
            return result;
        }
        case Yaml.Kind.SCALAR: {
            const instance = node;
            const type = Yaml.determineScalarType(instance);
            const value = instance.value;
            switch (type) {
                case Yaml.ScalarType.null: {
                    return new stringASTNode_1.StringASTNode(parent, false, '', instance.startPosition, instance.endPosition);
                }
                case Yaml.ScalarType.bool: {
                    return new booleanASTNode_1.BooleanASTNode(parent, Yaml.parseYamlBoolean(value), instance.startPosition, instance.endPosition);
                }
                case Yaml.ScalarType.int: {
                    return new numberASTNode_1.NumberASTNode(parent, Yaml.parseYamlInteger(value), true, instance.startPosition, instance.endPosition);
                }
                case Yaml.ScalarType.float: {
                    return new numberASTNode_1.NumberASTNode(parent, Yaml.parseYamlFloat(value), false, instance.startPosition, instance.endPosition);
                }
                case Yaml.ScalarType.string: {
                    return new stringASTNode_1.StringASTNode(parent, false, value, instance.startPosition, instance.endPosition);
                }
            }
        }
    }
    return new nullASTNode_1.NullASTNode(parent, 0, 0);
}
exports.buildAstRecursively = buildAstRecursively;
