'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var requestOption = {
    method: 'POST'
};
function describeSecurityGroups(client, region, vpcId, securityGroupName) {
    return __awaiter(this, void 0, void 0, function* () {
        var params = {
            'RegionId': region,
            'VpcId': vpcId
        };
        if (securityGroupName) {
            Object.assign(params, {
                'SecurityGroupName': securityGroupName
            });
        }
        const describeRs = yield client.request('DescribeSecurityGroups', params, requestOption);
        const securityGroup = describeRs.SecurityGroups.SecurityGroup;
        return securityGroup;
    });
}
function authSecurityGroupRule(ecsClient, region, securityGroupId, protocol, port) {
    return __awaiter(this, void 0, void 0, function* () {
        var params = {
            'RegionId': region,
            'SecurityGroupId': securityGroupId,
            'IpProtocol': protocol,
            'PortRange': port,
            'Policy': 'Accept',
            'SourceCidrIp': '0.0.0.0/0',
            'NicType': 'intranet'
        };
        const rs = yield ecsClient.request('AuthorizeSecurityGroup', params, requestOption);
        return rs;
    });
}
function authDefaultSecurityGroupRules(ecsClient, region, securityGroupId) {
    return __awaiter(this, void 0, void 0, function* () {
        const sgRules = [
            { protocol: 'TCP', port: '80/80' },
            { protocol: 'TCP', port: '443/443' },
            { protocol: 'ICMP', port: '-1/-1' },
            { protocol: 'TCP', port: '22/22' }
        ];
        for (const rule of sgRules) {
            yield authSecurityGroupRule(ecsClient, region, securityGroupId, rule.protocol, rule.port);
        }
    });
}
function createSecurityGroup(ecsClient, region, vpcId, securityGroupName) {
    return __awaiter(this, void 0, void 0, function* () {
        var params = {
            'RegionId': region,
            'SecurityGroupName': securityGroupName,
            'Description': 'default security group created by fc fun',
            'VpcId': vpcId,
            'SecurityGroupType': 'normal'
        };
        var createRs;
        try {
            createRs = yield ecsClient.request('CreateSecurityGroup', params, requestOption);
        }
        catch (ex) {
            throw ex;
        }
        return createRs.SecurityGroupId;
    });
}
module.exports = {
    describeSecurityGroups,
    createSecurityGroup,
    authDefaultSecurityGroupRules
};
