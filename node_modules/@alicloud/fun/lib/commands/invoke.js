'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fc = require('../fc');
const fs = require('fs-extra');
const path = require('path');
const validate = require('../../lib/commands/validate');
const getProfile = require('../../lib/profile').getProfile;
const { red, yellow } = require('colors');
const { getTriggerMetas } = require('../../lib/import/service');
const { getTpl, detectTplPath } = require('../tpl');
const { promptForFunctionSelection } = require('../init/prompt');
const { eventPriority, readJsonFromFile } = require('../utils/file');
const { findFunctionsInTpl, parseFunctionPath, findFirstFunctionName } = require('../definition');
const _ = require('lodash');
const invokeTypeSupport = ['async', 'sync'];
const ROS_FUNCTION_TYPE = 'ALIYUN::FC::Function';
const ROS_TEMPLATE_PATH = path.join('.fun', 'tmp', 'rosTemplate.json');
function findFunctionInCurrentDirectory(invokeFunctionName) {
    return __awaiter(this, void 0, void 0, function* () {
        const tpl = yield getAndVerifyTpl();
        if (!invokeFunctionName) {
            const funcName = findFirstFunctionName(tpl);
            console.log(`\nMissing invokeName argument, Fun will use the first function ${yellow(funcName)} as invokeName\n`);
            const array = funcName.split('/');
            return {
                serviceName: _.first(array),
                functionName: _.last(array)
            };
        }
        const functions = findFunctionsInTpl(tpl, (functionName, functionRes) => {
            return functionName === invokeFunctionName;
        });
        if (functions.length === 1) {
            return {
                serviceName: _.first(functions).serviceName,
                functionName: _.first(functions).functionName
            };
        }
        if (functions.length > 1) {
            return yield promptForFunctionSelection(functions);
        }
        throw new Error(`don't exit function: ${invokeFunctionName}`);
    });
}
function getAndVerifyTpl() {
    return __awaiter(this, void 0, void 0, function* () {
        const tplPath = yield detectTplPath(false);
        if (!tplPath) {
            throw new Error(red('Current folder not a fun project\nThe folder must contains template.[yml|yaml] or faas.[yml|yaml] .'));
        }
        yield validate(tplPath);
        return yield getTpl(tplPath);
    });
}
function certainInvokeName(invokeName) {
    return __awaiter(this, void 0, void 0, function* () {
        const [parsedServiceName, parsedFunctionName] = parseFunctionPath(invokeName);
        if (!parsedServiceName) {
            // fun invoke || fun invoke functionName
            return yield findFunctionInCurrentDirectory(parsedFunctionName);
        }
        return {
            serviceName: parsedServiceName,
            functionName: parsedFunctionName
        };
    });
}
function displayTriggerInfo(httpTrigger, accountId, region, serviceName, functionName) {
    const methods = httpTrigger.triggerConfig['methods'];
    const qualifier = httpTrigger.qualifier ? `.${httpTrigger.qualifier}` : '';
    console.warn(`
  methods: ${yellow(methods)}
  entry point: ` + yellow(`https://${accountId}.${region}.fc.aliyuncs.com/2016-08-15/proxy/${serviceName}${qualifier}/${functionName}/`));
}
function printHttpTriggerWarning(httpTrigger, serviceName, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        const profile = yield getProfile();
        const triggerNames = httpTrigger.map(p => p.triggerName).join(',');
        console.warn(red(`\n  Currently fun invoke does not support functions with HTTP trigger`));
        console.warn(`\n  function(name: ${functionName}) with http trigger(name: ${triggerNames}) can only be invoked with http trigger URL.`);
        httpTrigger.forEach(trigger => {
            displayTriggerInfo(trigger, profile.accountId, profile.defaultRegion, serviceName, functionName);
        });
        console.log(`\n  users can make remote calls through console, postman or fcli command line tools.`);
    });
}
function getHttpTrigger(serviceName, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        const triggers = yield getTriggerMetas(serviceName, functionName);
        if (_.isEmpty(triggers)) {
            return [];
        }
        const httpTrigger = triggers.filter(t => t.triggerType === 'http' || t.triggerType === 'https');
        if (_.isEmpty(httpTrigger)) {
            return [];
        }
        return httpTrigger;
    });
}
function findFunctionInRosTemplate(rosTemplate, serviceName, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        const resourceName = serviceName + functionName;
        if (rosTemplate.Resources[resourceName] && rosTemplate.Resources[resourceName].Type === ROS_FUNCTION_TYPE) {
            return {
                rosServiceName: rosTemplate.Resources[resourceName].Properties.ServiceName,
                rosFunctionName: rosTemplate.Resources[resourceName].Properties.FunctionName
            };
        }
        return {};
    });
}
function invoke(invokeName, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let { serviceName, functionName } = yield certainInvokeName(invokeName);
        const absRosTemplatePath = path.resolve(ROS_TEMPLATE_PATH);
        if (yield fs.pathExists(absRosTemplatePath)) {
            const rosTemplate = yield readJsonFromFile(absRosTemplatePath);
            const rosFuntion = yield findFunctionInRosTemplate(rosTemplate, serviceName, functionName);
            if (!_.isEmpty(rosFuntion)) {
                serviceName = rosFuntion.rosServiceName;
                functionName = rosFuntion.rosFunctionName;
            }
        }
        const invocationType = options.invocationType;
        const upperCase = _.lowerCase(invocationType);
        if (!_.includes(invokeTypeSupport, upperCase)) {
            throw new Error(red(`error: unexpected argumentï¼š${invocationType}`));
        }
        const event = yield eventPriority(options);
        const httpTriggers = yield getHttpTrigger(serviceName, functionName);
        if (_.isEmpty(httpTriggers)) {
            return yield fc.invokeFunction({ serviceName, functionName, event, invocationType: _.upperFirst(upperCase) });
        }
        yield printHttpTriggerWarning(httpTriggers, serviceName, functionName);
    });
}
module.exports = invoke;
