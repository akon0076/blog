'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { red } = require('colors');
const fcBuilders = require('@alicloud/fc-builders');
const fs = require('fs-extra');
const path = require('path');
const definition = require('../../definition');
const { generateMergedTpl } = require('../../tpl');
function transformDotnetCodeUri(baseDir, serviceName, functionName, functionRes) {
    return __awaiter(this, void 0, void 0, function* () {
        const { CodeUri: codeUri, Handler: handler, Runtime: runtime } = functionRes.Properties;
        const handlerPaths = handler.split('::');
        if (handlerPaths.length !== 3) {
            throw new Error(red(`handler ${handler} is invalid`));
        }
        const assemblyFileName = `${handlerPaths[0]}.dll`;
        const assemblyFilePath = path.resolve(baseDir, codeUri, assemblyFileName);
        if (yield fs.pathExists(assemblyFilePath)) {
            return;
        }
        const artifactDir = path.resolve(codeUri, 'bin', 'Debug', runtime);
        const absCodeUri = path.resolve(baseDir, codeUri);
        const builder = new fcBuilders.Builder(serviceName, functionName, absCodeUri, runtime, artifactDir, false, ['local']);
        yield builder.build();
        functionRes.Properties.CodeUri = artifactDir;
    });
}
function mergeTplWithoutBuildYml(templates = [], invokeName) {
    return __awaiter(this, void 0, void 0, function* () {
        let isDotnetcore = false;
        const { tpl, tplPath } = yield generateMergedTpl(templates, false, [], false);
        if (!invokeName) {
            invokeName = definition.findFirstFunctionName(tpl);
        }
        const { serviceName, serviceRes, functionName, functionRes } = definition.findFunctionInTpl(invokeName, tpl);
        if (functionRes && functionRes.Properties.Runtime === 'dotnetcore2.1') {
            isDotnetcore = true;
        }
        return {
            isDotnetcore,
            tpl, tplPath,
            serviceName, serviceRes,
            functionName, functionRes
        };
    });
}
module.exports = {
    transformDotnetCodeUri,
    mergeTplWithoutBuildYml
};
