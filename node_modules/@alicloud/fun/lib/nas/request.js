'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { getFcClient } = require('../client');
const { readFileChunk } = require('./cp/file');
const { getServiceMeta } = require('../import/service');
const path = require('path');
const constants = require('./constants');
const PROXY = 'proxy';
function getNasHttpTriggerPath(serviceName) {
    let nasServiceName;
    if (serviceName.indexOf(constants.FUN_NAS_SERVICE_PREFIX) !== 0) {
        nasServiceName = constants.FUN_NAS_SERVICE_PREFIX + serviceName;
    }
    else {
        nasServiceName = serviceName;
    }
    return `/${PROXY}/${nasServiceName}/${constants.FUN_NAS_FUNCTION}/`;
}
function getRequest(path, query, headers) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield request('GET', path, query, headers);
    });
}
function postRequest(path, query, body, headers, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield request('POST', path, query, body, headers, opts);
    });
}
function request(method, path, query, body, headers, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        let fcClient = yield getFcClient({
            timeout: constants.FUN_NAS_TIMEOUT
        });
        headers = Object.assign(headers || {}, {
            'X-Fc-Log-Type': 'Tail'
        });
        const res = yield fcClient.request(method, path, query, body, headers, opts || {});
        const data = (res && res.data) || {};
        if (data.error) {
            throw new Error(data.error);
        }
        return res;
    });
}
function statsRequest(dstPath, nasHttpTriggerPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'stats';
        const query = { dstPath };
        return yield getRequest(urlPath, query);
    });
}
function sendCmdRequest(nasHttpTriggerPath, cmd) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'commands';
        const query = {};
        const body = { cmd };
        return yield postRequest(urlPath, query, body);
    });
}
function nasPathExsit(nasHttpTriggerPath, nasPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'path/exsit';
        const query = { path: nasPath };
        return yield getRequest(urlPath, query);
    });
}
function checkFileHash(nasHttpTriggerPath, nasFile, fileHash) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'file/check';
        const query = { nasFile, fileHash };
        return yield getRequest(urlPath, query);
    });
}
function sendZipRequest(nasHttpTriggerPath, nasPath, tmpNasZipPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const cmd = `cd ${path.dirname(nasPath)} && zip -r ${tmpNasZipPath} ${path.basename(nasPath)}`;
        return yield sendCmdRequest(nasHttpTriggerPath, cmd);
    });
}
function sendDownLoadRequest(nasHttpTriggerPath, tmpNasZipPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'download';
        const query = {};
        const body = { tmpNasZipPath };
        return yield postRequest(urlPath, query, body, null, {
            rawBuf: true
        });
    });
}
function sendUnzipRequest(nasHttpTriggerPath, dstDir, nasZipFile, unzipFiles, noClobber) {
    return __awaiter(this, void 0, void 0, function* () {
        let cmd;
        if (noClobber) {
            cmd = `unzip -q -n ${nasZipFile} -d ${dstDir}`;
        }
        else {
            cmd = `unzip -q -o ${nasZipFile} -d ${dstDir}`;
        }
        for (let unzipFile of unzipFiles) {
            cmd = cmd + ` '${unzipFile}'`;
        }
        return yield sendCmdRequest(nasHttpTriggerPath, cmd);
    });
}
function sendCleanRequest(nasHttpTriggerPath, nasZipFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'clean';
        const query = { nasZipFile };
        return yield getRequest(urlPath, query);
    });
}
function createSizedNasFile(nasHttpTriggerPath, nasZipFile, fileSize) {
    return __awaiter(this, void 0, void 0, function* () {
        const cmd = `dd if=/dev/zero of=${nasZipFile} count=0 bs=1 seek=${fileSize}`;
        return yield sendCmdRequest(nasHttpTriggerPath, cmd);
    });
}
function uploadChunkFile(nasHttpTriggerPath, nasFile, zipFilePath, offSet) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'file/chunk/upload';
        const fileStart = offSet.start;
        const fileSize = offSet.size;
        const query = {
            nasFile,
            fileStart: fileStart.toString()
        };
        const body = yield readFileChunk(zipFilePath, fileStart, fileSize);
        const headers = {};
        return yield postRequest(urlPath, query, body, headers);
    });
}
// 检查远端 NAS 临时文件夹是否存在
// 不存在则创建，且权限赋予
function checkRemoteNasTmpDir(nasHttpTriggerPath, remoteNasTmpDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'tmp/check';
        const query = { remoteNasTmpDir };
        return yield getRequest(urlPath, query);
    });
}
function getVersion(nasHttpTriggerPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const urlPath = nasHttpTriggerPath + 'version';
        return yield getRequest(urlPath);
    });
}
function getNasConfig(serviceName) {
    return __awaiter(this, void 0, void 0, function* () {
        const serviceMeta = yield getServiceMeta(serviceName);
        return serviceMeta.nasConfig;
    });
}
function changeNasFilePermission(nasHttpTriggerPath, filePath, filePermission) {
    return __awaiter(this, void 0, void 0, function* () {
        const cmd = `chmod ${filePermission} ${filePath}`;
        return yield sendCmdRequest(nasHttpTriggerPath, cmd);
    });
}
module.exports = {
    getVersion, getNasConfig, getNasHttpTriggerPath,
    createSizedNasFile, uploadChunkFile, statsRequest,
    checkRemoteNasTmpDir, checkFileHash, changeNasFilePermission, nasPathExsit,
    sendZipRequest, sendDownLoadRequest, sendCleanRequest, sendCmdRequest, sendUnzipRequest
};
