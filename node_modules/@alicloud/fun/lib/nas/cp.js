'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs = require('fs-extra');
const path = require('path');
const debug = require('debug')('fun:nas:cp');
const { red, green } = require('colors');
const { extractZipTo } = require('../package/zip');
const { isDir, isFile } = require('./cp/file');
const { writeBufToFile } = require('./cp/file');
const { deployNasService } = require('./init');
const { uploadFolder, uploadFile } = require('./cp/upload');
const { getNasHttpTriggerPath, statsRequest } = require('./request');
const { resolveLocalPath, isNasProtocol, endWithSlash } = require('./path');
const { checkWritePerm, getNasId, getNasPathAndServiceFromNasUri } = require('./support');
const { sendCleanRequest, sendZipRequest, sendDownLoadRequest, nasPathExsit } = require('./request');
function checkCpDstPath(srcPath, dstStats, recursive, noClobber, nasHttpTriggerPath, noTargetDirectory = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const { resolvedDst, dstPath, dstPathExists, parentDirOfDstPathExists, dstPathIsDir, dstPathIsFile, dstPathEndWithSlash } = dstStats;
        var errorInf;
        if (!recursive && dstPathExists) {
            if (dstPathIsFile && !dstPathEndWithSlash) {
                if (!noClobber) {
                    return resolvedDst;
                }
                errorInf = `${dstPath} already exists.`;
            }
            if (dstPathIsFile && dstPathEndWithSlash) {
                errorInf = `${dstPath} : Not a directory`;
            }
            if (dstPathIsDir && isNasProtocol(dstPath)) {
                const newDstPath = path.posix.join(resolvedDst, path.basename(srcPath));
                const statsRes = yield statsRequest(newDstPath, nasHttpTriggerPath);
                const stats = statsRes.data;
                const newDstStats = {
                    dstPath: `${dstPath}/${path.basename(srcPath)}`,
                    resolvedDst: newDstPath,
                    dstPathEndWithSlash: false,
                    dstPathExists: stats.exists,
                    parentDirOfDstPathExists: stats.parentDirExists,
                    dstPathIsDir: stats.isDir,
                    dstPathIsFile: stats.isFile
                };
                return yield checkCpDstPath(srcPath, newDstStats, recursive, noClobber, nasHttpTriggerPath);
            }
            if (dstPathIsDir && !isNasProtocol(dstPath)) {
                // TO DO: 目标路径是本地路径
                return path.join(resolvedDst, path.basename(srcPath));
            }
        }
        else if (!recursive && !dstPathExists) {
            if (dstPathEndWithSlash) {
                errorInf = `nas cp: cannot create regular file ${dstPath}: Not a directory`;
            }
            else if (parentDirOfDstPathExists) {
                return resolvedDst;
            }
            else {
                errorInf = `nas cp: cannot create regular file ${dstPath}: No such file or directory`;
            }
        }
        else if (recursive && dstPathExists) {
            if (dstPathIsDir && isNasProtocol(dstPath)) {
                if (noTargetDirectory) {
                    return resolvedDst;
                }
                return path.posix.join(resolvedDst, path.basename(srcPath));
            }
            if (dstPathIsDir && !isNasProtocol(dstPath)) {
                return path.join(resolvedDst, path.basename(srcPath));
            }
            if (dstPathIsFile && dstPathEndWithSlash) {
                errorInf = `nas cp: failed to access ${dstPath}: Not a directory`;
            }
            if (dstPathIsFile && !dstPathEndWithSlash) {
                errorInf = `nas cp: cannot overwrite non-directory ${dstPath} with directory ${srcPath}`;
            }
        }
        else if (recursive && !dstPathExists) {
            if (parentDirOfDstPathExists) {
                return resolvedDst;
            }
            errorInf = `nas cp: cannot create directory ${dstPath}: No such file or directory`;
        }
        throw new Error(errorInf);
    });
}
function cpFromNasToLocal(nasPath, localDir, tpl, baseDir, tplPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const { nasPath: resolveNasPath, serviceName } = getNasPathAndServiceFromNasUri(nasPath, tpl);
        // fun nas init
        yield deployNasService(baseDir, tpl, serviceName, tplPath);
        const nasHttpTriggerPath = getNasHttpTriggerPath(serviceName);
        const res = yield nasPathExsit(nasHttpTriggerPath, resolveNasPath);
        if (!res.data) {
            throw new Error(`${nasPath} is not exsit.`);
        }
        console.log(`zipping ${resolveNasPath}`);
        const tmpNasZipPath = path.posix.join(path.dirname(resolveNasPath), `.fun-nas-generated.zip`);
        yield sendZipRequest(nasHttpTriggerPath, resolveNasPath, tmpNasZipPath);
        console.log(`${green('✔')} zip done`);
        console.log('downloading...');
        const localZipPath = path.join(process.cwd(), '.fun', 'nas', '.fun-nas-generated.zip');
        const rs = yield sendDownLoadRequest(nasHttpTriggerPath, tmpNasZipPath);
        console.log(`${green('✔')} download done`);
        yield writeBufToFile(localZipPath, rs.data);
        console.log('unzipping file');
        yield extractZipTo(localZipPath, path.resolve(localDir));
        console.log(`${green('✔')} unzip done`);
        // clean
        yield sendCleanRequest(nasHttpTriggerPath, tmpNasZipPath);
        yield fs.remove(localZipPath);
        console.log(`${green('✔')} download completed`);
    });
}
function cpFromLocalToNas({ baseDir, tpl, tplPath, localPath, dstPath, localNasTmpDir, isSync, recursive, noClobber, noTargetDirectory }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { nasPath, serviceName } = getNasPathAndServiceFromNasUri(dstPath, tpl);
        // fun nas init
        yield deployNasService(baseDir, tpl, serviceName, tplPath);
        // 这里将 path.resolve(srcPath) 传进去, 是因为在 windows 平台上利用 git bash 输入的本地路径问题
        // git bash 读取 windows 本地路径是以 '/' 作为分隔符的, 因此在此处需要将其转换为以 '\'作为分隔符
        const resolvedSrc = resolveLocalPath(path.resolve(localPath));
        if (!(yield fs.pathExists(resolvedSrc))) {
            throw new Error(`${resolvedSrc} not exist`);
        }
        const srcPathIsDir = yield isDir(resolvedSrc);
        const srcPathIsFile = yield isFile(resolvedSrc);
        if (srcPathIsDir && !recursive) {
            throw new Error('Can not copy folder without option -r/--recursive');
        }
        const nasId = getNasId(tpl, serviceName);
        const nasHttpTriggerPath = getNasHttpTriggerPath(serviceName);
        debug(`checking dst path ${dstPath}...`);
        const statsRes = yield statsRequest(nasPath, nasHttpTriggerPath);
        const stats = statsRes.data;
        const dstStats = {
            dstPath: dstPath,
            resolvedDst: nasPath,
            dstPathEndWithSlash: endWithSlash(nasPath),
            dstPathExists: stats.exists,
            parentDirOfDstPathExists: stats.parentDirExists,
            dstPathIsDir: stats.isDir,
            dstPathIsFile: stats.isFile
        };
        let actualDstPath = yield checkCpDstPath(resolvedSrc, dstStats, recursive, noClobber, nasHttpTriggerPath, noTargetDirectory);
        if (isSync && srcPathIsDir) {
            actualDstPath = nasPath;
        }
        const permTip = checkWritePerm(stats, nasId, nasPath);
        if (permTip) {
            console.log(red(`Warning: ${permTip}`));
        }
        if (srcPathIsDir) {
            yield uploadFolder(resolvedSrc, actualDstPath, nasHttpTriggerPath, localNasTmpDir, noClobber);
        }
        else if (srcPathIsFile) {
            yield uploadFile(resolvedSrc, actualDstPath, nasHttpTriggerPath);
        }
        else {
            throw new Error(`${localPath} has the same file stat and folder stat`);
        }
    });
}
function isCpFromLocalToNas(srcPath, targetPath) {
    return !isNasProtocol(srcPath) && isNasProtocol(targetPath);
}
function isCpFromNasToLocal(srcPath, targetPath) {
    return isNasProtocol(srcPath) && !isNasProtocol(targetPath);
}
function cp(srcPath, targetPath, recursive, noClobber, localNasTmpDir, tpl, tplPath, baseDir, isSync, noTargetDirectory = false) {
    return __awaiter(this, void 0, void 0, function* () {
        if (srcPath === undefined || targetPath === undefined) {
            console.log('Input path empty error, please input again!');
            return;
        }
        debug('cp ' + (recursive ? '-r ' : '') + srcPath + ' to ' + targetPath);
        if (isCpFromNasToLocal(srcPath, targetPath)) {
            yield cpFromNasToLocal(srcPath, targetPath, tpl, baseDir, tplPath);
        }
        else if (isCpFromLocalToNas(srcPath, targetPath)) {
            yield cpFromLocalToNas({ localPath: srcPath, dstPath: targetPath,
                baseDir, tpl, tplPath, localNasTmpDir,
                isSync, recursive, noClobber, noTargetDirectory
            });
        }
        else if (isNasProtocol(srcPath) && isNasProtocol(targetPath)) {
            //nas => nas
            throw new Error('Not support copy NAS files to another NAS!');
        }
        else {
            throw new Error('Format of path not support');
        }
    });
}
module.exports = cp;
