'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs = require('fs-extra');
const path = require('path');
const nas = require('../nas');
const definition = require('../definition');
const constants = require('./constants');
const { sleep } = require('../time');
const { green, red } = require('colors');
const { statsRequest, getNasHttpTriggerPath } = require('./request');
const { checkWritePerm, isNasServerStale, extractNasMappingsFromNasYml } = require('./support');
const _ = require('lodash');
function generateNasServiceRes(serviceName, vpcConfig, nasConfig, zipCodePath) {
    return {
        'Type': 'Aliyun::Serverless::Service',
        'Properties': {
            'Description': `service for fc nas used for service ${serviceName}`,
            'VpcConfig': vpcConfig,
            'NasConfig': nasConfig
        },
        [constants.FUN_NAS_FUNCTION]: {
            Type: 'Aliyun::Serverless::Function',
            Properties: {
                Handler: 'index.handler',
                Runtime: 'nodejs8',
                CodeUri: zipCodePath,
                Timeout: 600,
                MemorySize: 256,
                EnvironmentVariables: {
                    PATH: '/code/.fun/root/usr/bin'
                }
            },
            Events: {
                httpTrigger: {
                    Type: 'HTTP',
                    Properties: {
                        AuthType: 'FUNCTION',
                        Methods: ['POST', 'GET']
                    }
                }
            }
        }
    };
}
function deployNasService(baseDir, tpl, service, tplPath) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('\nstart fun nas init...');
        const zipCodePath = path.resolve(__dirname, '../utils/fun-nas-server/dist/fun-nas-server.zip');
        if (!(yield fs.pathExists(zipCodePath))) {
            throw new Error('could not find ../utils/fun-nas-server/dist/fun-nas-server.zip');
        }
        const versionFilePath = path.resolve(__dirname, '../utils/fun-nas-server/dist/VERSION');
        if (!(yield fs.pathExists(versionFilePath))) {
            throw new Error('could not find ../utils/fun-nas-server/dist/VERSION');
        }
        const version = (yield fs.readFile(versionFilePath)).toString();
        let permTipArr = [];
        for (const { serviceName, serviceRes } of definition.findServices(tpl.Resources)) {
            if (service && service !== serviceName) {
                continue;
            }
            const serviceProps = (serviceRes || {}).Properties;
            const nasConfig = (serviceProps || {}).NasConfig;
            const vpcConfig = (serviceProps || {}).VpcConfig;
            if (!nasConfig) {
                continue;
            }
            const nasServiceName = constants.FUN_NAS_SERVICE_PREFIX + serviceName;
            console.log(`checking if ${nasServiceName} needs to be deployed...`);
            if (yield isNasServerStale(nasServiceName, nasConfig, version)) {
                console.log(`Waiting for service ${nasServiceName} to be deployed...`);
                yield require('../deploy/deploy-by-tpl').deployService({
                    baseDir, tplPath,
                    serviceName: nasServiceName,
                    serviceRes: generateNasServiceRes(serviceName, vpcConfig, nasConfig, zipCodePath),
                    onlyConfig: false, skipTrigger: false, useNas: false
                });
                console.log(green(`service ${nasServiceName} deploy success\n`));
                const nasMappings = yield nas.convertNasConfigToNasMappings(nas.getDefaultNasDir(baseDir), nasConfig, serviceName);
                const nasMappingsFromNasYml = yield extractNasMappingsFromNasYml(baseDir, serviceName);
                const mergedNasMappings = _.unionWith([...nasMappings, ...nasMappingsFromNasYml], _.isEqual);
                console.log(green(`Create local NAS directory of service ${serviceName}:`));
                const nasId = nas.getNasIdFromNasConfig(nasConfig);
                const nasHttpTriggerPath = getNasHttpTriggerPath(serviceName);
                // 延迟 1 秒，为保证 nas server 部署完成并成功执行
                // TODO: 利用类似部署 ID 的标识来验证部署的的成功
                yield sleep(1000);
                for (let mappings of mergedNasMappings) {
                    console.log(`\t${path.resolve(baseDir, mappings.localNasDir)}`);
                    const statsRes = yield statsRequest(mappings.remoteNasDir, nasHttpTriggerPath);
                    const stats = statsRes.data;
                    const permTip = checkWritePerm(stats, nasId, mappings.remoteNasDir);
                    if (permTip) {
                        permTipArr.push(permTip);
                    }
                }
            }
            else {
                console.log(`skip deploying ${nasServiceName}, which has been deployed`);
            }
        }
        for (let permTip of permTipArr) {
            console.log(red(`\nWarning: fun nas init: ${permTip}`));
        }
        console.log(green('fun nas init Success\n'));
    });
}
module.exports = { deployNasService };
