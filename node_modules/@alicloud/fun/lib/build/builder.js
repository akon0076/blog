'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const docker = require('../docker');
const { execSync } = require('child_process');
const fs = require('fs-extra');
const buildOpts = require('./build-opts');
const fcBuilders = require('@alicloud/fc-builders');
const { processorTransformFactory } = require('../error-processor');
const path = require('path');
const buildkit = require('../buildkit');
function buildInDocker(serviceName, serviceRes, functionName, functionRes, baseDir, codeUri, funcArtifactDir, verbose, preferredImage, stages) {
    return __awaiter(this, void 0, void 0, function* () {
        const opts = yield buildOpts.generateBuildContainerBuildOpts(serviceName, serviceRes, functionName, functionRes, baseDir, codeUri, funcArtifactDir, verbose, preferredImage, stages);
        const usedImage = opts.Image;
        if (!preferredImage) {
            yield docker.pullImageIfNeed(usedImage);
        }
        console.log('\nbuild function using image: ' + usedImage);
        // todo: 1. create container, copy source code to container
        // todo: 2. build and then copy artifact output 
        const errorTransform = processorTransformFactory({
            serviceName: serviceName,
            functionName: functionName,
            errorStream: process.stderr
        });
        const exitRs = yield docker.run(opts, null, process.stdout, errorTransform);
        if (exitRs.StatusCode !== 0) {
            throw new Error(`build function ${serviceName}/${functionName} error`);
        }
    });
}
function buildInBuildkit(serviceName, serviceRes, functionName, functionRes, baseDir, codeUri, funcArtifactDir, verbose, stages) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetBuildStage = 'buildresult';
        const dockerfilePath = path.join(codeUri, '.buildkit.generated.dockerfile');
        yield buildOpts.generateDockerfileForBuildkit(dockerfilePath, serviceName, serviceRes, functionName, functionRes, baseDir, codeUri, funcArtifactDir, verbose, stages, targetBuildStage);
        // exec build
        execSync(`buildctl build --no-cache --frontend dockerfile.v0 --local context=${baseDir} --local dockerfile=${path.dirname(dockerfilePath)} --opt filename=${path.basename(dockerfilePath)} --opt target=${targetBuildStage} --output type=local,dest=${baseDir}`, {
            stdio: 'inherit'
        });
        // clean
        yield fs.remove(dockerfilePath);
        const dockerfileInArtifact = path.join(funcArtifactDir, path.basename(dockerfilePath));
        if (yield fs.pathExists(dockerfileInArtifact)) {
            yield fs.remove(dockerfileInArtifact);
        }
        const passwdMount = yield buildkit.resolvePasswdMount(baseDir);
        if (passwdMount) {
            const pwdFilePath = passwdMount.Source;
            yield fs.remove(pwdFilePath);
            const pwdFileInArtifact = path.join(funcArtifactDir, path.basename(pwdFilePath));
            if (yield fs.pathExists(pwdFileInArtifact)) {
                yield fs.remove(pwdFileInArtifact);
            }
        }
    });
}
function buildInProcess(serviceName, functionName, codeUri, runtime, funcArtifactDir, verbose, stages) {
    return __awaiter(this, void 0, void 0, function* () {
        const builder = new fcBuilders.Builder(serviceName, functionName, codeUri, runtime, funcArtifactDir, verbose, stages);
        yield builder.build();
    });
}
module.exports = { buildInDocker, buildInProcess, buildInBuildkit };
