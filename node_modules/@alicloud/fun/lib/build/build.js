'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const path = require('path');
const debug = require('debug')('fun:build');
const fs = require('fs-extra');
const yaml = require('js-yaml');
const nas = require('../nas');
const ncp = require('../utils/ncp');
const util = require('util');
const ncpAsync = util.promisify(ncp);
const taskflow = require('./taskflow');
const template = require('./template');
const artifact = require('./artifact');
const docker = require('../docker');
const uuid = require('uuid');
const parser = require('./parser');
const builder = require('./builder');
const fcBuilders = require('@alicloud/fc-builders');
const { yellow } = require('colors');
const { green, red } = require('colors');
const { recordMtimes } = require('../utils/file');
const { findFunctionsInTpl } = require('../definition');
const { DEFAULT_NAS_PATH_SUFFIX } = require('../tpl');
const { dockerBuildAndPush, buildkitBuild } = require('./build-image');
const { execSync } = require('child_process');
const { isCustomContainerRuntime } = require('../common/model/runtime');
const _ = require('lodash');
const { convertDockerfileToBuildkitFormat } = require('../buildkit');
const { promptForConfirmContinue } = require('../init/prompt');
function convertFunYmlToFunfile(funymlPath, funfilePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const generatedFunfile = yield parser.funymlToFunfile(funymlPath);
        yield fs.writeFile(funfilePath, generatedFunfile);
    });
}
function convertFunfileToDockerfile(funfilePath, dockerfilePath, runtime, serviceName, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        const dockerfileContent = yield parser.funfileToDockerfile(funfilePath, runtime, serviceName, functionName);
        yield fs.writeFile(dockerfilePath, dockerfileContent);
    });
}
function formatDockerfileForBuildkit(dockerfilePath, fromSrcToDstPairs, baseDir, targetBuildStage) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fromSrcToDstPairs) {
            debug('There are no fromSrcToDstPairs');
            return;
        }
        const dockerfileContent = yield convertDockerfileToBuildkitFormat(dockerfilePath, fromSrcToDstPairs, baseDir, targetBuildStage);
        yield fs.writeFile(dockerfilePath, dockerfileContent);
    });
}
function assertCodeUriExist(codeUri) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(yield fs.pathExists(codeUri))) {
            throw new Error(`CodeUri ${codeUri} is not exist.`);
        }
    });
}
function copyNasArtifactFromLocal(rootArtifactsDir, funcArtifactDir) {
    return __awaiter(this, void 0, void 0, function* () {
        // if .fun/nas exist in funcArtifactDir , fun will move to rootartifactsDir
        const funcNasFolder = path.join(funcArtifactDir, DEFAULT_NAS_PATH_SUFFIX);
        const rootNasFolder = path.join(rootArtifactsDir, DEFAULT_NAS_PATH_SUFFIX);
        if ((yield fs.pathExists(funcNasFolder)) && funcNasFolder !== rootNasFolder) {
            console.log(`moving ${funcNasFolder} to ${rootNasFolder}`);
            yield fs.ensureDir(rootNasFolder);
            yield ncpAsync(funcNasFolder, rootNasFolder);
            yield fs.remove(funcNasFolder);
        }
    });
}
function copyNasArtifactFromImage(nasMappings, imageTag) {
    return __awaiter(this, void 0, void 0, function* () {
        if (nasMappings) {
            for (let nasMapping of nasMappings) {
                const localNasDir = nasMapping.localNasDir;
                let remoteNasDir = nasMapping.remoteNasDir;
                if (!remoteNasDir.endsWith('/')) {
                    remoteNasDir += '/';
                }
                try {
                    console.log('copy from container ' + remoteNasDir + '.' + ' to ' + localNasDir);
                    yield docker.copyFromImage(imageTag, remoteNasDir + '.', localNasDir);
                }
                catch (e) {
                    debug(`copy from image ${imageTag} directory ${remoteNasDir} to ${localNasDir} error`, e);
                }
            }
        }
    });
}
function copyNasArtifact(nasMappings, imageTag, rootArtifactsDir, funcArtifactDir) {
    return __awaiter(this, void 0, void 0, function* () {
        yield copyNasArtifactFromLocal(rootArtifactsDir, funcArtifactDir);
        yield copyNasArtifactFromImage(nasMappings, imageTag);
    });
}
function getOrConvertFunfile(codeUri) {
    return __awaiter(this, void 0, void 0, function* () {
        const funfilePath = path.join(codeUri, 'Funfile');
        const funymlPath = path.join(codeUri, 'fun.yml');
        let funfileExist = yield fs.pathExists(funfilePath);
        const funymlExist = yield fs.pathExists(funymlPath);
        // convert funyml to Funfile if funyml exist and Funfile dont exist
        if (!funfileExist && funymlExist) {
            console.log('detecting fun.yml but no Funfile, Fun will convert fun.yml to Funfile');
            yield convertFunYmlToFunfile(funymlPath, funfilePath);
            funfileExist = true;
        }
        if (funfileExist) {
            return funfilePath;
        }
        return null;
    });
}
function processFunfile(serviceName, serviceRes, codeUri, funfilePath, baseDir, funcArtifactDir, runtime, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(yellow('Funfile exist, Fun will use container to build forcely'));
        const dockerfilePath = path.join(codeUri, '.Funfile.generated.dockerfile');
        yield convertFunfileToDockerfile(funfilePath, dockerfilePath, runtime, serviceName, functionName);
        const nasConfig = (serviceRes.Properties || {}).NasConfig;
        let nasMappings;
        if (nasConfig) {
            nasMappings = yield nas.convertNasConfigToNasMappings(nas.getDefaultNasDir(baseDir), nasConfig, serviceName);
        }
        const tag = `fun-cache-${uuid.v4()}`;
        const imageTag = yield docker.buildImage(codeUri, dockerfilePath, tag);
        // copy fun install generated artifact files to artifact dir
        console.log(`copying function artifact to ${funcArtifactDir}`);
        yield docker.copyFromImage(imageTag, '/code/.', funcArtifactDir);
        // process nas folder
        yield copyNasArtifact(nasMappings, imageTag, baseDir, funcArtifactDir);
        yield fs.remove(dockerfilePath);
        return imageTag;
    });
}
function processFunfileForBuildkit(serviceName, serviceRes, codeUri, funfilePath, baseDir, funcArtifactDir, runtime, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(yellow('Funfile exist and useBuildkit is specified, Fun will use buildkit to build'));
        const dockerfilePath = path.join(codeUri, '.Funfile.buildkit.generated.dockerfile');
        yield convertFunfileToDockerfile(funfilePath, dockerfilePath, runtime, serviceName, functionName);
        const fromSrcToDstPairs = [{
                'src': '/code',
                'dst': funcArtifactDir
            }];
        const nasConfig = (serviceRes.Properties || {}).NasConfig;
        let nasMappings;
        if (nasConfig) {
            nasMappings = yield nas.convertNasConfigToNasMappings(nas.getDefaultNasDir(baseDir), nasConfig, serviceName);
            if (nasMappings) {
                for (let nasMapping of nasMappings) {
                    const localNasDir = nasMapping.localNasDir;
                    let remoteNasDir = nasMapping.remoteNasDir;
                    if (!remoteNasDir.endsWith('/')) {
                        remoteNasDir += '/';
                    }
                    fromSrcToDstPairs.push({
                        'src': remoteNasDir,
                        'dst': localNasDir
                    });
                }
            }
        }
        // 复制本地 NAS 内容
        yield copyNasArtifactFromLocal(baseDir, funcArtifactDir);
        // 生成 dockerfile
        const targetBuildStage = 'buildresult';
        yield formatDockerfileForBuildkit(dockerfilePath, fromSrcToDstPairs, baseDir, targetBuildStage);
        execSync(`buildctl build --no-cache --frontend dockerfile.v0 --local context=${baseDir} --local dockerfile=${path.dirname(dockerfilePath)} --opt target=${targetBuildStage} --opt filename=${path.basename(dockerfilePath)} --output type=local,dest=${baseDir}`, {
            stdio: 'inherit'
        });
        yield fs.remove(dockerfilePath);
    });
}
const metaFiles = ['.', 'pom.xml', 'package.json', 'package-lock.json', 'requirements.txt', 'composer.json',
    path.join('src', 'main', 'java')
];
function recordMetaData(baseDir, functions, tplPath, metaPath, buildOps) {
    return __awaiter(this, void 0, void 0, function* () {
        const metaPaths = _.flatMap(functions, (func => {
            const { functionRes } = func;
            const codeUri = (functionRes.Properties || {}).CodeUri;
            const asbBaseDir = path.resolve(baseDir);
            let absCodeUri;
            if (!codeUri) {
                absCodeUri = asbBaseDir;
            }
            else {
                absCodeUri = path.resolve(baseDir, codeUri);
            }
            return metaFiles
                .map(metaFile => { return path.join(absCodeUri, metaFile); })
                .filter(metaFile => { return fs.pathExistsSync(metaFile); });
        }));
        yield recordMtimes([...metaPaths, tplPath], buildOps, metaPath);
    });
}
function buildFunction(buildName, tpl, baseDir, useDocker, useBuildkit, stages, verbose, tplPath, assumeYes) {
    return __awaiter(this, void 0, void 0, function* () {
        const buildStage = _.includes(stages, 'build');
        const escapeDockerArgsInBuildFC = +process.env.escapeDockerArgsInBuildFC;
        const setBuildkitArgsDefaultInBuildFC = +process.env.setBuildkitArgsDefaultInBuildFC;
        if (setBuildkitArgsDefaultInBuildFC) {
            debug(`set useBuildkit arg default when building function`);
            useDocker = false;
            useBuildkit = true;
        }
        else if (useDocker && escapeDockerArgsInBuildFC) {
            debug(`escape useDocker arg when building function`);
            useDocker = false;
            useBuildkit = true;
        }
        if (useDocker) {
            console.log(green(`start ${buildStage ? 'building' : 'installing'} functions using docker`));
        }
        else if (useBuildkit) {
            console.log(green(`start ${buildStage ? 'building' : 'installing'} functions using buildkit`));
        }
        else {
            console.log(green(`start ${buildStage ? 'building' : 'installing'} function dependencies without docker`));
        }
        debug(`${buildStage ? 'buildName' : 'installName'}: ${buildName}`);
        const buildFuncs = template.findBuildFuncs(buildName, tpl);
        const skippedBuildFuncs = [];
        let rootArtifactsDir;
        if (buildStage) {
            rootArtifactsDir = yield artifact.generateRootArtifactDirectory(baseDir);
            yield artifact.cleanDirectory(rootArtifactsDir);
        }
        else {
            rootArtifactsDir = baseDir;
        }
        yield detectFunFile(baseDir, tpl);
        for (let func of buildFuncs) {
            const { functionName, serviceName, serviceRes, functionRes } = func;
            console.log();
            console.log(green(`building ${serviceName}/${functionName}`));
            const runtime = functionRes.Properties.Runtime;
            const codeUri = functionRes.Properties.CodeUri;
            if (isCustomContainerRuntime(runtime)) {
                if (!buildStage) {
                    continue;
                }
                if (!useDocker && !useBuildkit) {
                    throw new Error(`Runtime custom-container must use --use-docker or --use-buildkit`);
                }
                if (useDocker) {
                    yield dockerBuildAndPush(codeUri, functionRes.Properties.CustomContainerConfig.Image, baseDir, functionName, serviceName);
                }
                else if (useBuildkit) {
                    const msg = `Use fun build to build image and push to ${functionRes.Properties.CustomContainerConfig.Image}.Please confirm to continue.`;
                    if (!assumeYes && !(yield promptForConfirmContinue(msg))) {
                        skippedBuildFuncs.push(func);
                        continue;
                    }
                    yield buildkitBuild(codeUri, functionRes.Properties.CustomContainerConfig.Image, baseDir, functionName, serviceName);
                }
                continue;
            }
            const absCodeUri = path.resolve(baseDir, functionRes.Properties.CodeUri);
            yield assertCodeUriExist(absCodeUri);
            if ((runtime === 'java8' || runtime === 'java11') && (absCodeUri.endsWith('.zip') || absCodeUri.endsWith('.jar') || absCodeUri.endsWith('.war'))) {
                console.warn(red(`\nDetectionWarning: your codeuri is '${codeUri}', and 'fun build' will not compile your functions. It is recommended that you modify ${serviceName}/${functionName}'s 'CodeUri' property to the directory where 'pom.xml' is located.`));
            }
            let funcArtifactDir;
            if (buildStage) {
                funcArtifactDir = yield artifact.generateArtifactDirectory(rootArtifactsDir, serviceName, functionName);
                yield artifact.cleanDirectory(funcArtifactDir);
            }
            else {
                funcArtifactDir = absCodeUri;
            }
            const Builder = fcBuilders.Builder;
            const taskFlows = yield Builder.detectTaskFlow(runtime, absCodeUri);
            const funfilePath = yield getOrConvertFunfile(absCodeUri);
            let imageTag;
            // if Funfile exist,use docker or buildkit.
            if (funfilePath) {
                if (useBuildkit || escapeDockerArgsInBuildFC) {
                    yield processFunfileForBuildkit(serviceName, serviceRes, absCodeUri, funfilePath, baseDir, funcArtifactDir, runtime, functionName);
                    useDocker = false;
                    useBuildkit = true;
                }
                else { // force docker if funfilePath exist and escapeDockerArgsInBuildFC not exist
                    imageTag = yield processFunfile(serviceName, serviceRes, absCodeUri, funfilePath, baseDir, funcArtifactDir, runtime, functionName);
                    useDocker = true;
                }
            }
            // For build stage, Fun needn't compile functions only if there are no manifest file and no Funfile.
            // For install stage, Fun needn't compile functions only if there are no manifest file.
            const manifestExist = !(_.isEmpty(taskFlows) || taskflow.isOnlyDefaultTaskFlow(taskFlows));
            if ((buildStage && (!funfilePath && !manifestExist))
                || (!buildStage && !manifestExist)) {
                debug(`could not find any manifest file for ${func.serviceName}/${func.functionName}, [${stages}] stage for manifest will be skipped`);
                skippedBuildFuncs.push(func);
                continue;
            }
            if (useBuildkit) {
                yield builder.buildInBuildkit(serviceName, serviceRes, functionName, functionRes, baseDir, absCodeUri, funcArtifactDir, verbose, stages);
            }
            else if (useDocker) {
                yield builder.buildInDocker(serviceName, serviceRes, functionName, functionRes, baseDir, absCodeUri, funcArtifactDir, verbose, imageTag, stages);
            }
            else {
                yield builder.buildInProcess(serviceName, functionName, absCodeUri, runtime, funcArtifactDir, verbose, stages);
            }
        }
        if (buildStage) {
            const updatedTemplateContent = template.updateTemplateResources(tpl, buildFuncs, skippedBuildFuncs, baseDir, rootArtifactsDir);
            yield fs.writeFile(path.join(rootArtifactsDir, 'template.yml'), yaml.dump(updatedTemplateContent));
            // save meta data
            yield recordMetaData(baseDir, buildFuncs, tplPath, path.resolve(rootArtifactsDir, 'meta.json'), {
                'useDocker': useDocker,
                'verbose': verbose,
                'buildName': buildName
            });
            console.log(green('\nBuild Success\n'));
            console.log('Built artifacts: ' + path.relative(baseDir, rootArtifactsDir));
            console.log('Built template: ' + path.relative(baseDir, path.join(rootArtifactsDir, 'template.yml')));
        }
        else {
            console.log(green('\nInstall Success\n'));
        }
    });
}
function detectFunFile(baseDir, tpl) {
    return __awaiter(this, void 0, void 0, function* () {
        const funfilePath = path.join(baseDir, 'Funfile');
        if (yield fs.pathExists(funfilePath)) {
            const codeUris = findFunctionsInTpl(tpl).map(func => {
                return path.resolve(baseDir, func.functionRes.Properties.CodeUri);
            });
            if (!_.includes(codeUris, baseDir)) {
                console.warn(red(`\nFun detected that the '${path.resolve(funfilePath)}' is not included in any CodeUri.\nPlease make sure if it is the right configuration. if yes, ignore please.`));
            }
        }
    });
}
module.exports = {
    buildFunction, copyNasArtifact, getOrConvertFunfile, copyNasArtifactFromLocal
};
