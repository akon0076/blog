'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { AptTask, PipTask, ShellTask } = require('./task');
const Context = require('./context');
const { FunModule } = require('./module');
const path = require('path');
function installPackage(runtime, codeUri, pkgType, pkgName, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const ctx = yield new Context(runtime, codeUri);
        try {
            switch (pkgType) {
                case 'apt':
                    yield new AptTask(options.name, runtime, codeUri, pkgName, options.local, null, options.env, ctx, options.verbose).run();
                    break;
                case 'pip':
                    yield new PipTask(options.name, runtime, codeUri, pkgName, options.local, null, options.env, ctx, options.verbose).run();
                    break;
                case 'module':
                    // TODO
                    break;
                default:
                    throw new Error(`unknow package type %${options.packageType}`);
            }
        }
        finally {
            yield ctx.teardown();
        }
    });
}
function findAllTargetsFromTasks(tasks) {
    const targets = [];
    for (const t of tasks) {
        const target = t.attrs.target;
        if (target) {
            targets.push(target);
        }
    }
    return targets;
}
function installFromYaml(file, verbose) {
    return __awaiter(this, void 0, void 0, function* () {
        const funModule = FunModule.load(file);
        const runtime = funModule.runtime;
        const codeUri = path.dirname(file);
        const tasks = funModule.tasks;
        const targets = findAllTargetsFromTasks(tasks);
        const ctx = yield new Context(runtime, codeUri, targets);
        try {
            for (const t of tasks) {
                if (t.type === 'pip') {
                    const pipTask = new PipTask(t.attrs.name, runtime, codeUri, t.attrs.pip, t.attrs.local, t.attrs.target, t.attrs.env, ctx, verbose);
                    yield pipTask.run();
                }
                else if (t.type === 'apt') {
                    const aptTask = new AptTask(t.attrs.name, runtime, codeUri, t.attrs.apt, t.attrs.local, t.attrs.target, t.attrs.env, ctx, verbose);
                    yield aptTask.run();
                }
                else if (t.type === 'shell') {
                    const shellTask = new ShellTask(t.attrs.name, runtime, codeUri, t.attrs.shell, t.attrs.cwd, t.attrs.env, ctx, verbose);
                    yield shellTask.run();
                }
                else {
                    console.error('unkown task %s', t);
                }
            }
        }
        finally {
            yield ctx.teardown();
        }
    });
}
module.exports = {
    installFromYaml,
    installPackage
};
