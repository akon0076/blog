'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { getFcClient } = require('../client');
const { getTemplateFile, getCodeUri, checkResource, outputTemplateFile, getTemplateHeader, createProgressBar } = require('./utils');
const { parseServiceResource } = require('./service-parser');
const { parseFunctionResource } = require('./function-parser');
const { parseTriggerResource } = require('./trigger-parser');
const httpx = require('httpx');
const path = require('path');
const unzipper = require('unzipper');
const debug = require('debug')('fun:import:service');
const { green, grey, yellow } = require('colors');
function getServiceMeta(serviceName) {
    return __awaiter(this, void 0, void 0, function* () {
        const fc = yield getFcClient();
        const { data } = yield fc.getService(serviceName);
        return data;
    });
}
function listServiceMetas() {
    return __awaiter(this, void 0, void 0, function* () {
        const fc = yield getFcClient();
        const { data } = yield fc.listServices();
        return data.services;
    });
}
function getFunctionMetas(serviceName) {
    return __awaiter(this, void 0, void 0, function* () {
        const fc = yield getFcClient();
        const { data } = yield fc.listFunctions(serviceName);
        return data.functions;
    });
}
function getTriggerMetas(serviceName, functionName) {
    return __awaiter(this, void 0, void 0, function* () {
        const fc = yield getFcClient();
        const { data } = yield fc.listTriggers(serviceName, functionName);
        return data.triggers;
    });
}
function getFunctionResource(serviceName, functionMeta, fullOutputDir, recursive, onlyConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const functionResource = parseFunctionResource(functionMeta);
        const functionName = functionMeta.functionName;
        if (!onlyConfig) {
            yield outputFunctionCode(serviceName, functionName, fullOutputDir);
            functionResource.Properties.CodeUri = getCodeUri(serviceName, functionName);
        }
        else {
            console.log(`    ${green('✔')} ${functionName} - ${grey('Function')}`);
        }
        if (recursive) {
            const triggerMetas = yield getTriggerMetas(serviceName, functionName);
            if (triggerMetas && triggerMetas.length > 0) {
                functionResource.Events = {};
                for (const triggerMeta of triggerMetas) {
                    debug('Trigger metadata: %s', triggerMeta);
                    functionResource.Events[triggerMeta.triggerName] = parseTriggerResource(triggerMeta);
                    console.log(`        ${green('✔')} ${triggerMeta.triggerName} - ${grey('Trigger')}`);
                }
            }
        }
        return functionResource;
    });
}
function outputFunctionCode(serviceName, functionName, fullOutputDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const fc = yield getFcClient();
        const { data } = yield fc.getFunctionCode(serviceName, functionName);
        const response = yield httpx.request(data.url, { timeout: 36000000, method: 'GET' }); // 10 hours
        const len = parseInt(response.headers['content-length'], 10);
        const bar = createProgressBar(`${green(':loading')} ${functionName} downloading :bar :rate/bps :percent :etas`, { total: len });
        response.on('data', (chunk) => {
            bar.tick(chunk.length);
        });
        response.on('end', () => {
            console.log(`    ${green('✔')} ${functionName} - ${grey('Function')}`);
        });
        const fullTargetCodeDir = path.join(fullOutputDir, serviceName, functionName);
        return yield new Promise((resolve, reject) => {
            response.pipe(unzipper.Extract({ path: fullTargetCodeDir })).on('error', err => {
                bar.interrupt(err);
                reject(err);
            }).on('finish', resolve);
        });
    });
}
function getServiceResource(serviceMeta, fullOutputDir, recursive, onlyConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        debug('Service metadata: %s', serviceMeta);
        const serviceName = serviceMeta.serviceName;
        const serviceResource = parseServiceResource(serviceMeta);
        console.log(`${green('✔')} ${serviceName} - ${grey('Service')}`);
        if (recursive) {
            const functionMetas = yield getFunctionMetas(serviceName);
            if (functionMetas && functionMetas.length > 0) {
                for (const functionMeta of functionMetas) {
                    debug('Function metadata: %s', functionMeta);
                    const functionName = functionMeta.functionName;
                    const functionResource = yield getFunctionResource(serviceName, functionMeta, fullOutputDir, recursive, onlyConfig);
                    serviceResource[functionName] = functionResource;
                }
            }
        }
        return serviceResource;
    });
}
function checkService(serviceMetas, content, skipIfExists) {
    for (const serviceMeta of serviceMetas) {
        try {
            checkResource(serviceMeta.serviceName, content);
            serviceMeta.exists = false;
        }
        catch (error) {
            if (!skipIfExists) {
                throw error;
            }
            serviceMeta.exists = true;
        }
    }
}
function importService(serviceName, outputDir = '.', recursive = true, onlyConfig = false, skipIfExists = true) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('\nImport service resources: ');
        let serviceMetas = [];
        if (serviceName) {
            const serviceMeta = yield getServiceMeta(serviceName);
            serviceMetas.push(serviceMeta);
        }
        else {
            serviceMetas = yield listServiceMetas();
        }
        if (serviceMetas.length === 0) {
            console.log(yellow('No service resources found.\n'));
            return;
        }
        const fullOutputDir = path.resolve(process.cwd(), outputDir);
        debug('Output Dir: %s', fullOutputDir);
        debug('Custom domain metadata: %s', serviceMetas);
        const templateFile = getTemplateFile(fullOutputDir);
        let content;
        let templateFilePath;
        if (templateFile) {
            content = templateFile.content;
            templateFilePath = templateFile.templateFilePath;
            checkResource(serviceName, content);
        }
        else {
            content = getTemplateHeader();
            templateFilePath = path.resolve(fullOutputDir, 'template.yml');
        }
        checkService(serviceMetas, content, skipIfExists);
        for (const serviceMeta of serviceMetas) {
            const serviceName = serviceMeta.serviceName;
            if (serviceMeta.exists) {
                console.log(`${yellow('skip')} ${serviceName} - ${grey('Service')}`);
            }
            else {
                content.Resources[serviceName] = yield getServiceResource(serviceMeta, fullOutputDir, recursive, onlyConfig);
            }
        }
        outputTemplateFile(templateFilePath, content);
        console.log('Service import finished\n');
    });
}
module.exports = {
    getFunctionResource,
    outputFunctionCode,
    getServiceResource,
    importService,
    getServiceMeta,
    listServiceMetas,
    getTriggerMetas
};
