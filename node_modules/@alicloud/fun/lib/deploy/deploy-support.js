'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs = require('fs-extra');
const ram = require('../ram');
const debug = require('debug')('fun:deploy');
const promiseRetry = require('../retry');
const getProfile = require('../profile').getProfile;
const { green, red } = require('colors');
const { processApiParameters } = require('./deploy-support-api');
const { getCloudApiClient, getSlsClient, getMnsClient } = require('../client');
const { getOtsClient, getOtsPopClient, getFcClient, getFnFClient } = require('../client');
const _ = require('lodash');
function makeLogstoreIndex(projectName, logstoreName) {
    return __awaiter(this, void 0, void 0, function* () {
        const sls = yield getSlsClient();
        // create index if index not exist.
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                try {
                    yield sls.getIndexConfig(projectName, logstoreName);
                    return;
                }
                catch (ex) {
                    if (ex.code !== 'IndexConfigNotExist') {
                        debug('error when getIndexConfig, projectName is %s, logstoreName is %s, error is: \n%O', projectName, logstoreName, ex);
                        throw ex;
                    }
                }
                // create default logstore index. index configuration is same with sls console.
                debug('logstore index not exist, try to create a default index for project %s logstore %s', projectName, logstoreName);
                yield sls.createIndex(projectName, logstoreName, {
                    ttl: 10,
                    line: {
                        caseSensitive: false,
                        chn: false,
                        token: [...', \'";=()[]{}?@&<>/:\n\t\r']
                    }
                });
                debug('create default index success for project %s logstore %s', projectName, logstoreName);
            }
            catch (ex) {
                debug('error when createIndex, projectName is %s, logstoreName is %s, error is: \n%O', projectName, logstoreName, ex);
                console.log(red(`\t\t\tretry ${times} times`));
                retry(ex);
            }
        }));
    });
}
function makeLogstore({ projectName, logstoreName, ttl = 3600, shardCount = 1 }) {
    return __awaiter(this, void 0, void 0, function* () {
        const sls = yield getSlsClient();
        let exists = true;
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield sls.getLogStore(projectName, logstoreName);
            }
            catch (ex) {
                if (ex.code !== 'LogStoreNotExist') {
                    debug('error when getLogStore, projectName is %s, logstoreName is %s, error is: \n%O', projectName, logstoreName, ex);
                    console.log(red(`\t\tretry ${times} times`));
                    retry(ex);
                }
                else {
                    exists = false;
                }
            }
        }));
        if (!exists) {
            yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield sls.createLogStore(projectName, logstoreName, {
                        ttl,
                        shardCount
                    });
                }
                catch (ex) {
                    if (ex.code === 'Unauthorized') {
                        throw ex;
                    }
                    debug('error when createLogStore, projectName is %s, logstoreName is %s, error is: \n%O', projectName, logstoreName, ex);
                    console.log(red(`\t\tretry ${times} times`));
                    retry(ex);
                }
            }));
        }
        else {
            yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield sls.updateLogStore(projectName, logstoreName, {
                        ttl,
                        shardCount
                    });
                }
                catch (ex) {
                    debug('error when updateLogStore, projectName is %s, logstoreName is %s, error is: \n%O', projectName, logstoreName, ex);
                    if (ex.code === 'Unauthorized') {
                        throw ex;
                    }
                    if (ex.code !== 'ParameterInvalid' && ex.message !== 'no parameter changed') {
                        console.log(red(`\t\tretry ${times} times`));
                        retry(ex);
                    }
                    else {
                        throw ex;
                    }
                }
            }));
        }
    });
}
function createSlsProject(slsClient, projectName, description) {
    return __awaiter(this, void 0, void 0, function* () {
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield slsClient.createProject(projectName, {
                    description
                });
            }
            catch (ex) {
                if (ex.code === 'Unauthorized') {
                    throw ex;
                }
                else if (ex.code === 'ProjectAlreadyExist') {
                    throw new Error(red(`error: sls project ${projectName} already exist, it may be in other region or created by other users.`));
                }
                else if (ex.code === 'ProjectNotExist') {
                    throw new Error(red(`Please go to https://sls.console.aliyun.com/ to open the LogServce.`));
                }
                else {
                    debug('error when createProject, projectName is %s, error is: \n%O', projectName, ex);
                    console.log(red(`\tretry ${times} times`));
                    retry(ex);
                }
            }
        }));
    });
}
function slsProjectExist(slsClient, projectName) {
    return __awaiter(this, void 0, void 0, function* () {
        let projectExist = true;
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield slsClient.getProject(projectName);
            }
            catch (ex) {
                if (ex.code === 'Unauthorized') {
                    throw new Error(red(`Log Service '${projectName}' may create by others, you should use a unique project name.`));
                }
                else if (ex.code !== 'ProjectNotExist') {
                    debug('error when getProject, projectName is %s, error is: \n%O', projectName, ex);
                    console.log(red(`\tretry ${times} times`));
                    retry(ex);
                }
                else {
                    projectExist = false;
                }
            }
        }));
        return projectExist;
    });
}
function makeSlsProject(projectName, description) {
    return __awaiter(this, void 0, void 0, function* () {
        const sls = yield getSlsClient();
        const projectExist = yield slsProjectExist(sls, projectName);
        let create = false;
        if (projectExist) {
            // no update project api
            // only description can be updated by console.
            debug(`sls project exists, but could not be updated`);
        }
        else {
            yield createSlsProject(sls, projectName, description);
            create = true;
        }
        return create;
    });
}
function makeSlsAuto(projectName, description, logstoreName) {
    return __awaiter(this, void 0, void 0, function* () {
        yield makeSlsProject(projectName, description);
        yield makeLogstore({
            projectName,
            logstoreName
        });
        yield makeLogstoreIndex(projectName, logstoreName);
    });
}
function makeMnsTopic(topicName, properties) {
    return __awaiter(this, void 0, void 0, function* () {
        var region = properties.Region;
        const mnsClient = yield getMnsClient(topicName, region);
        // just for deepping copy
        var params = JSON.parse(JSON.stringify(properties));
        delete params.Region;
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                let res;
                res = yield mnsClient.createTopic(topicName, params);
                console.log('mms create topic response status code = ', res.code);
            }
            catch (ex) {
                console.log(red(`\tretry ${times} times`));
                retry(ex);
            }
        }));
    });
}
function listCustomDomains() {
    return __awaiter(this, void 0, void 0, function* () {
        const fc = yield getFcClient();
        const rs = yield fc.listCustomDomains();
        return rs.data.customDomains;
    });
}
function makeCustomDomain({ domainName, protocol, routeConfig, certConfig }) {
    return __awaiter(this, void 0, void 0, function* () {
        const fc = yield getFcClient();
        var customDomain;
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                customDomain = yield fc.getCustomDomain(domainName);
            }
            catch (ex) {
                if (ex.code !== 'DomainNameNotFound') {
                    debug('error when getCustomDomain, domainName is %s, error is: \n%O', domainName, ex);
                    console.log(red(`\tretry ${times} times`));
                    retry(ex);
                }
            }
        }));
        const options = {
            protocol
        };
        if (routeConfig) {
            Object.assign(options, {
                routeConfig
            });
        }
        if (!_.isEmpty(certConfig)) {
            let privateKey = certConfig.PrivateKey;
            let certificate = certConfig.Certificate;
            if (privateKey && privateKey.endsWith('.pem')) {
                certConfig.PrivateKey = yield fs.readFile(privateKey, 'utf-8');
            }
            if (certificate && certificate.endsWith('.pem')) {
                certConfig.Certificate = yield fs.readFile(certificate, 'utf-8');
            }
            Object.assign(options, {
                certConfig
            });
        }
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!customDomain) {
                    customDomain = yield fc.createCustomDomain(domainName, options);
                }
                else {
                    customDomain = yield fc.updateCustomDomain(domainName, options);
                }
            }
            catch (ex) {
                debug('error when createCustomDomain or updateCustomDomain, domainName is %s, options is %j, error is: \n%O', domainName, options, ex);
                console.log(red(`\tretry ${times} times`));
                retry(ex);
            }
        }));
        return customDomain;
    });
}
function makeGroup(group) {
    return __awaiter(this, void 0, void 0, function* () {
        const ag = yield getCloudApiClient();
        const groupName = group.name;
        const groupDescription = group.description;
        var findGroup;
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                var groups = yield ag.describeApiGroups({
                    GroupName: groupName
                });
                debug(`describeApiGroups response ${JSON.stringify(groups)}`);
                var list = groups.ApiGroupAttributes.ApiGroupAttribute;
                findGroup = list.find((item) => {
                    return item.GroupName === groupName;
                });
                if (!findGroup) {
                    findGroup = yield ag.createApiGroup({
                        GroupName: groupName,
                        Description: groupDescription
                    });
                }
            }
            catch (ex) {
                debug('error when makeGroup, error is: \n%O', ex);
                console.log(red(`\tretry ${times} times`));
                retry(ex);
            }
        }));
        return findGroup;
    });
}
function getDefaultRequestConfig(method, requestPath) {
    return {
        'requestProtocol': 'HTTP',
        'postBodyDescription': '',
        'requestMode': 'PASSTHROUGH'
    };
}
function makeApi(group, { stageName, requestPath, method, roleArn, apiName, serviceName, functionName, serviceTimeout = 3000, auth = {}, visibility = 'Private', requestConfig = {}, resultConfig = {}, requestParameters = [], serviceParameters = [], serviceParametersMap = [], description, forceNonceCheck, appCodeAuthType, allowSignatureMethod, disableInternet, webSocketApiType, errorCodeSamples }) {
    return __awaiter(this, void 0, void 0, function* () {
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                const ag = yield getCloudApiClient();
                const result = yield ag.describeApis({
                    ApiName: apiName,
                    GroupId: group.GroupId
                });
                debug(`describeApis response: ${JSON.stringify(result)}`);
                var apiSummarys = result.ApiSummarys && result.ApiSummarys.ApiSummary;
                var api;
                if (apiSummarys) {
                    api = apiSummarys.find(summary => summary.ApiName === apiName);
                }
                const mergedRequestConfig = Object.assign(getDefaultRequestConfig(method), {
                    'requestHttpMethod': method,
                    'requestPath': requestPath
                }, requestConfig);
                const { apiRequestParameters, apiServiceParameters, apiServiceParametersMap } = processApiParameters(requestParameters, serviceParameters, serviceParametersMap);
                const profile = yield getProfile();
                var params = {
                    GroupId: group.GroupId,
                    ApiName: apiName,
                    Visibility: visibility,
                    Description: description || 'The awesome api generated by fun',
                    AuthType: auth.type || 'ANONYMOUS',
                    RequestConfig: JSON.stringify(mergedRequestConfig),
                    RequestParameters: JSON.stringify(apiRequestParameters),
                    ServiceParameters: JSON.stringify(apiServiceParameters),
                    ServiceParametersMap: JSON.stringify(apiServiceParametersMap),
                    ServiceConfig: JSON.stringify({
                        'ServiceProtocol': 'FunctionCompute',
                        'ContentTypeValue': 'application/x-www-form-urlencoded; charset=UTF-8',
                        'Mock': 'FALSE',
                        'MockResult': '',
                        'ServiceAddress': '',
                        'ServicePath': '',
                        'ServiceHttpMethod': '',
                        'ContentTypeCatagory': 'DEFAULT',
                        'ServiceVpcEnable': 'FALSE',
                        'ServiceTimeout': serviceTimeout,
                        FunctionComputeConfig: {
                            FcRegionId: profile.defaultRegion,
                            ServiceName: serviceName,
                            FunctionName: functionName,
                            RoleArn: roleArn
                        }
                    }),
                    ResultType: resultConfig.resultType || 'passthrough',
                    ResultSample: resultConfig.resultSample || 'result sample',
                    FailResultSample: resultConfig.failResultSample || 'failed samples',
                    DisableInternet: disableInternet || false,
                    ErrorCodeSamples: _.isEmpty(errorCodeSamples) ? [] : JSON.stringify(errorCodeSamples)
                };
                if (allowSignatureMethod) {
                    Object.assign(params, {
                        'allowSignatureMethod': allowSignatureMethod
                    });
                }
                if (webSocketApiType) {
                    Object.assign(params, {
                        'WebSocketApiType': webSocketApiType
                    });
                }
                if (appCodeAuthType) {
                    Object.assign(params, {
                        'AppCodeAuthType': appCodeAuthType
                    });
                }
                if (auth.type === 'APPOPENID' || auth.type === 'OPENID') {
                    var openidConf = auth.config || {};
                    params.OpenIdConnectConfig = JSON.stringify({
                        'IdTokenParamName': openidConf.idTokenParamName,
                        'OpenIdApiType': openidConf.openIdApiType || 'BUSINESS',
                        'PublicKeyId': openidConf.publicKeyId,
                        'PublicKey': openidConf.publicKey
                    });
                }
                if (forceNonceCheck !== undefined) {
                    Object.assign(params, {
                        ForceNonceCheck: forceNonceCheck
                    });
                }
                debug('api params is %j', params);
                if (!api) {
                    debug('create api');
                    api = yield ag.createApi(params);
                }
                else {
                    debug('modify api');
                    yield ag.modifyApi(Object.assign(params, {
                        ApiId: api.ApiId
                    }));
                }
                debug('deploy api, params is GroupId %s, ApiId %s, StageName: %s', group.GroupId, api.ApiId, stageName);
                yield ag.deployApi({
                    GroupId: group.GroupId,
                    ApiId: api.ApiId,
                    StageName: stageName,
                    Description: `deployed by fun at ${new Date().toISOString()}`
                });
                const apiDetail = yield ag.describeApi({
                    GroupId: group.GroupId,
                    ApiId: api.ApiId
                });
                console.log('    URL: %s %s://%s%s', green(apiDetail.RequestConfig.RequestHttpMethod), apiDetail.RequestConfig.RequestProtocol.toLowerCase(), group.SubDomain, apiDetail.RequestConfig.RequestPath);
                apiDetail.DeployedInfos.DeployedInfo.forEach((info) => {
                    if (info.DeployedStatus === 'DEPLOYED') {
                        console.log(green(`      stage: ${info.StageName}, deployed, version: ${info.EffectiveVersion}`));
                    }
                    else {
                        console.log(`      stage: ${info.StageName}, undeployed`);
                    }
                });
            }
            catch (ex) {
                if (ex.code === 'DuplicateRequestParamaters') {
                    throw new Error(red(ex.message));
                }
                else {
                    debug('error when makeApi, error is: \n%O', ex);
                    console.log(red(ex.message));
                    console.log(red(`\tretry ${times} times`));
                    retry(ex);
                }
                scrollTo;
            }
        }));
    });
}
function makeApiTrigger({ serviceName, functionName, triggerName, method = 'GET', requestPath, restApiId }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!restApiId) {
            const role = yield ram.makeRole('apigatewayAccessFC');
            debug('%j', role);
            const apiGroup = yield makeGroup({
                name: `fc_${serviceName}_${functionName}`,
                description: `api group for function compute ${serviceName}/${functionName}`
            });
            const apiName = `fc_${serviceName}_${functionName}_${requestPath.replace(/\//g, '_')}_${method}`;
            makeApi(apiGroup, {
                stageName: 'RELEASE',
                requestPath,
                method,
                roleArn: role.Role.Arn,
                apiName,
                serviceName,
                functionName
            });
        }
    });
}
function makeOtsInstance(instanceName, clusterType, description) {
    return __awaiter(this, void 0, void 0, function* () {
        const otsPopClient = yield getOtsPopClient();
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                try {
                    yield otsPopClient.request('GetInstance', {
                        'InstanceName': instanceName
                    });
                    return;
                }
                catch (ex) {
                    if (ex.code !== 'NotFound') {
                        throw ex;
                    }
                }
                yield otsPopClient.request('InsertInstance', {
                    InstanceName: instanceName,
                    ClusterType: clusterType,
                    Description: description
                }, {
                    method: 'POST'
                });
            }
            catch (ex) {
                if (ex.code === 'AuthFailed'
                    || ex.code === 'InvalidParameter'
                    || ex.code === 'QuotaExhausted') {
                    throw new Error(red(ex.message));
                }
                else {
                    debug('error when makeOtsInstance, error is: \n%O', ex);
                    console.error(red(`retry ${times} times`));
                    retry(ex);
                }
            }
        }));
    });
}
function makeOtsTable({ instanceName, tableName, primaryKeys }) {
    return __awaiter(this, void 0, void 0, function* () {
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                const client = yield getOtsClient(instanceName);
                var params = {
                    tableMeta: {
                        tableName: tableName,
                        primaryKey: primaryKeys
                    },
                    reservedThroughput: {
                        capacityUnit: {
                            read: 0,
                            write: 0
                        }
                    },
                    tableOptions: {
                        timeToLive: -1,
                        maxVersions: 1
                    },
                    streamSpecification: {
                        enableStream: true,
                        expirationTime: 1
                    }
                };
                const listData = yield client.listTable();
                if (listData.tableNames.length > 0 && listData.tableNames.indexOf(tableName) !== -1) {
                    console.log('tablestore table already exists, but could not be updated');
                }
                else {
                    yield client.createTable(params);
                }
            }
            catch (ex) {
                debug('error when makeOtsTable, error is: \n%O', ex);
                console.log(red(`retry ${times} times`));
                retry(ex);
            }
        }));
    });
}
function makeFlow({ name, definition, description, roleArn, type = 'FDL' }) {
    return __awaiter(this, void 0, void 0, function* () {
        const client = yield getFnFClient();
        let flowData;
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                flowData = yield client.describeFlow({
                    'Name': name
                });
            }
            catch (ex) {
                if (ex.code !== 'FlowNotExists') {
                    debug('error when makeFlow, error is: \n%O', ex);
                    console.log(red(`\tretry ${times} times`));
                    retry(ex);
                }
            }
        }));
        const params = {};
        _.forOwn({
            'Name': name,
            'Definition': definition,
            'Description': description,
            'RoleArn': roleArn,
            'Type': type
        }, (value, key) => {
            if (value) {
                params[key] = value;
            }
        });
        yield promiseRetry((retry, times) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!flowData) {
                    flowData = yield client.createFlow(params);
                }
                else {
                    flowData = yield client.updateFlow(params);
                }
            }
            catch (ex) {
                debug('error when createFlow or updateFlow, params is %j, error is \n%O', params, ex);
                console.log(red(`\t retry ${times} times`));
                retry(ex);
            }
        }));
    });
}
module.exports = {
    makeApi, makeFlow, makeGroup,
    makeOtsTable, makeLogstore, makeMnsTopic,
    makeApiTrigger, makeSlsProject, makeOtsInstance,
    makeCustomDomain, makeLogstoreIndex, makeSlsAuto,
    listCustomDomains
};
