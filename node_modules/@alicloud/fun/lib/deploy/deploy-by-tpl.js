'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs = require('fs-extra');
const path = require('path');
const yaml = require('js-yaml');
const requestP = require('request-promise');
const constants = require('../nas/constants');
const validate = require('../validate/validate');
const debug = require('debug')('fun:deploy');
const definition = require('../definition');
const date = require('date-and-time');
const { getFunctionImage } = require('../package/pushImage');
const { deployByRos } = require('./deploy-support-ros');
const { importService } = require('../import/service');
const { getProfile, mark } = require('../profile');
const { showTipsForNasYml } = require('../build/tips');
const { green, yellow, red } = require('colors');
const { displayTriggerInfo } = require('../../lib/trigger');
const { showResourcesChanges } = require('./deploy-diffs');
const { parseYamlWithCustomTag } = require('../parse');
const { promptForConfirmContinue } = require('../init/prompt');
const { getNasMappingsFromNasYml } = require('../nas/support');
const { getTriggerNameList, makeTrigger } = require('../trigger');
const { getTpl, getRootBaseDir, getNasYmlPath } = require('../tpl');
const { transformFunctionInDefinition, transformFlowDefinition } = require('../fnf');
const { makeService, makeFunction, deleteFunction, makeFcUtilsFunctionTmpDomainToken } = require('../fc');
const { FUNCTION_TYPE } = require('../import/constants');
const _ = require('lodash');
const TMP_DOMAIN_URL = 'https://1813774388953700.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/generate_tmp_domain_for_console.prod/generate_preview_domain_for_fun/';
const TMP_DOMAIN_EXPIRED_TIME_URL = 'https://1813774388953700.cn-shanghai.fc.aliyuncs.com/2016-08-15/proxy/generate_tmp_domain_for_console/get_expired_time/';
let { makeApi, makeFlow, makeApiTrigger, makeGroup, makeOtsTable, makeOtsInstance, makeMnsTopic, makeSlsProject, makeLogstore, makeLogstoreIndex, makeCustomDomain, listCustomDomains } = require('./deploy-support');
let { makeRole, attachPolicyToRole, makeAndAttachPolicy, normalizeRoleOrPoliceName, FNF_ASSUME_ROLE_POLICY } = require('../ram');
function extractFcRole(role) {
    const [, , , , path] = role.split(':');
    const [, roleName] = path.split('/');
    return roleName;
}
function deployTrigger(serviceName, functionName, triggerName, triggerDefinition) {
    return __awaiter(this, void 0, void 0, function* () {
        if (triggerDefinition.Type === 'Api') {
            yield makeApiTrigger({
                serviceName,
                functionName,
                triggerName,
                method: ((triggerDefinition.Properties || {}).Method || 'GET').toUpperCase(),
                requestPath: (triggerDefinition.Properties || {}).Path,
                restApiId: (triggerDefinition.Properties || {}).RestApiId
            });
        }
        else if (triggerDefinition.Type === 'Datahub') {
            console.error(`Try to create Datahub Trigger, but the SDK didn't OK.`);
        }
        else {
            yield makeTrigger({
                serviceName,
                functionName,
                triggerName,
                triggerType: triggerDefinition.Type,
                triggerProperties: triggerDefinition.Properties
            });
        }
    });
}
function deployTriggers(serviceName, functionName, events, tplPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (_.isEmpty(events)) {
            return;
        }
        let localTriggerNames = Object.keys(events);
        let onLineTriggerNames = yield getTriggerNameList({ serviceName, functionName });
        onLineTriggerNames.filter(x => !_.includes(localTriggerNames, x)).forEach(element => {
            console.warn(red(`\t\tThe trigger ${element} you configured in fc console does not match the local configuration.\n\t\tFun will not modify this trigger. You can remove this trigger manually through fc console if necessary`));
        });
        for (const [triggerName, triggerDefinition] of Object.entries(events)) {
            console.log(`\t\tWaiting for ${yellow(triggerDefinition.Type)} trigger ${triggerName} to be deployed...`);
            yield deployTrigger(serviceName, functionName, triggerName, triggerDefinition);
            const tpl = yield getTpl(tplPath);
            yield displayTriggerInfo(serviceName, functionName, triggerName, triggerDefinition.Type, triggerDefinition.Properties, '\t\t', tpl);
            console.log(green(`\t\ttrigger ${triggerName} deploy success`));
        }
    });
}
function deployFunction({ baseDir, nasConfig, vpcConfig, useNas, assumeYes, serviceName, functionName, functionRes, onlyConfig, tplPath, skipTrigger = false }) {
    return __awaiter(this, void 0, void 0, function* () {
        const properties = functionRes.Properties || {};
        const rs = yield makeFunction(baseDir, {
            serviceName,
            functionName,
            description: properties.Description,
            handler: properties.Handler,
            initializer: properties.Initializer,
            timeout: properties.Timeout,
            initializationTimeout: properties.InitializationTimeout,
            memorySize: properties.MemorySize,
            runtime: properties.Runtime,
            codeUri: properties.CodeUri,
            customContainerConfig: properties.CustomContainerConfig,
            cAPort: properties.CAPort,
            instanceType: properties.InstanceType,
            asyncConfiguration: properties.AsyncConfiguration,
            environmentVariables: properties.EnvironmentVariables,
            instanceConcurrency: properties.InstanceConcurrency,
            layers: properties.Layers,
            nasConfig,
            vpcConfig,
            InstanceLifecycleConfig: properties.InstanceLifecycleConfig
        }, onlyConfig, tplPath, useNas, assumeYes);
        if (!skipTrigger) {
            yield deployTriggers(serviceName, functionName, functionRes.Events, tplPath);
        }
        return rs;
    });
}
function reloadServiceRes(tplPath, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const tpl = yield getTpl(tplPath);
        for (let { serviceName, serviceRes } of definition.findServices(tpl.Resources)) {
            if (name === serviceName) {
                return serviceRes;
            }
        }
        return {};
    });
}
function deployFunctions({ baseDir, serviceName, serviceRes, onlyConfig, tplPath, skipTrigger, useNas, assumeYes }) {
    return __awaiter(this, void 0, void 0, function* () {
        const serviceProps = serviceRes.Properties || {};
        let deployedFunctions = [];
        let tplChanged;
        do {
            tplChanged = false;
            for (const [k, v] of Object.entries(serviceRes)) {
                if ((v || {}).Type === FUNCTION_TYPE) {
                    if (_.includes(deployedFunctions, k)) {
                        continue;
                    }
                    const beforeDeployLog = onlyConfig ? 'config to be updated' : 'to be deployed';
                    const afterDeployLog = onlyConfig ? 'config update success' : 'deploy success';
                    console.log(`\tWaiting for function ${k} ${beforeDeployLog}...`);
                    const rs = yield deployFunction({ baseDir, serviceName, onlyConfig, tplPath, skipTrigger, useNas,
                        functionName: k,
                        functionRes: v,
                        nasConfig: serviceProps.NasConfig,
                        vpcConfig: serviceProps.VpcConfig,
                        assumeYes
                    });
                    deployedFunctions.push(k);
                    console.log(green(`\tfunction ${k} ${afterDeployLog}`));
                    if (rs.tplChanged) {
                        serviceRes = yield reloadServiceRes(tplPath, serviceName);
                        tplChanged = true;
                        break;
                    }
                }
            }
        } while (tplChanged);
    });
}
function deployPolicy(resourceName, roleName, policy, curCount, product = 'Fc') {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof policy === 'string') {
            yield attachPolicyToRole(policy, roleName);
            return curCount;
        }
        const profile = yield getProfile();
        const policyName = normalizeRoleOrPoliceName(`Aliyun${product}GeneratedServicePolicy-${profile.defaultRegion}-${resourceName}${curCount}`);
        yield makeAndAttachPolicy(policyName, policy, roleName);
        return curCount + 1;
    });
}
function deployPolicies(resourceName, roleName, policies, product) {
    return __awaiter(this, void 0, void 0, function* () {
        let nextCount = 1;
        if (Array.isArray(policies)) {
            for (let policy of policies) {
                nextCount = yield deployPolicy(resourceName, roleName, policy, nextCount, product);
            }
        }
        else {
            nextCount = yield deployPolicy(resourceName, roleName, policies, nextCount, product);
        }
    });
}
function generateRoleNameSuffix(serviceName) {
    if (serviceName.startsWith(constants.FUN_NAS_SERVICE_PREFIX)) {
        return serviceName.substring(constants.FUN_NAS_SERVICE_PREFIX.length);
    }
    return serviceName;
}
function generateServiceRole({ serviceName, vpcConfig, nasConfig, logConfig, roleArn, policies, hasFunctionAsyncConfig, hasCustomContainerConfig }) {
    return __awaiter(this, void 0, void 0, function* () {
        const profile = yield getProfile();
        const defaultRegion = profile.defaultRegion;
        let role;
        let roleName;
        let createRoleIfNotExist = false;
        if (_.isNil(roleArn)) {
            roleName = `aliyunfcgeneratedrole-${defaultRegion}-${generateRoleNameSuffix(serviceName)}`;
            roleName = normalizeRoleOrPoliceName(roleName);
            createRoleIfNotExist = true;
        }
        else {
            try {
                roleName = extractFcRole(roleArn);
            }
            catch (ex) {
                throw new Error('The role you provided is not correct. You must provide the correct role arn.');
            }
        }
        // if roleArn has been configured, dont need `makeRole`, because `makeRole` need ram permissions.
        // However, in some cases, users do not want to configure ram permissions for ram users.
        // https://github.com/aliyun/fun/issues/182
        // https://github.com/aliyun/fun/pull/223
        if (!roleArn && (policies || !_.isEmpty(vpcConfig) || !_.isEmpty(logConfig) || !_.isEmpty(nasConfig) || hasFunctionAsyncConfig || hasCustomContainerConfig)) {
            // create role
            console.log(`\tmake sure role '${roleName}' is exist`);
            role = yield makeRole(roleName, createRoleIfNotExist);
            console.log(green(`\trole '${roleName}' is already exist`));
        }
        if (!roleArn && policies) { // if roleArn exist, then ignore polices
            console.log('\tattaching policies ' + JSON.stringify(policies) + ' to role: ' + roleName);
            yield deployPolicies(serviceName, roleName, policies);
            console.log(green('\tattached policies ' + JSON.stringify(policies) + ' to role: ' + roleName));
        }
        if (!roleArn && hasFunctionAsyncConfig) {
            console.log('\tattaching police \'AliyunFCInvocationAccess\' to role: ' + roleName);
            yield attachPolicyToRole('AliyunFCInvocationAccess', roleName);
            console.log(green('\tattached police \'AliyunFCInvocationAccess\' to role: ' + roleName));
            const mnsPolicyName = normalizeRoleOrPoliceName(`AliyunFcGeneratedMNSPolicy-${defaultRegion}-${serviceName}`);
            yield makeAndAttachPolicy(mnsPolicyName, {
                'Version': '1',
                'Statement': [{
                        'Action': [
                            'mns:SendMessage',
                            'mns:PublishMessage'
                        ],
                        'Resource': '*',
                        'Effect': 'Allow'
                    }]
            }, roleName);
        }
        if (!roleArn && (!_.isEmpty(vpcConfig) || !_.isEmpty(nasConfig))) {
            console.log('\tattaching police \'AliyunECSNetworkInterfaceManagementAccess\' to role: ' + roleName);
            yield attachPolicyToRole('AliyunECSNetworkInterfaceManagementAccess', roleName);
            console.log(green('\tattached police \'AliyunECSNetworkInterfaceManagementAccess\' to role: ' + roleName));
        }
        if (!roleArn && hasCustomContainerConfig) {
            console.log('\tattaching police \'AliyunContainerRegistryReadOnlyAccess\' to role: ' + roleName);
            yield attachPolicyToRole('AliyunContainerRegistryReadOnlyAccess', roleName);
            console.log(green('\tattached police \'AliyunContainerRegistryReadOnlyAccess\' to role: ' + roleName));
        }
        if (logConfig.Logstore && logConfig.Project) {
            if (!roleArn) {
                const logPolicyName = normalizeRoleOrPoliceName(`AliyunFcGeneratedLogPolicy-${defaultRegion}-${serviceName}`);
                yield makeAndAttachPolicy(logPolicyName, {
                    'Version': '1',
                    'Statement': [{
                            'Action': [
                                'log:PostLogStoreLogs'
                            ],
                            'Resource': `acs:log:*:*:project/${logConfig.Project}/logstore/${logConfig.Logstore}`,
                            'Effect': 'Allow'
                        }]
                }, roleName);
            }
        }
        else if (logConfig.LogStore || logConfig.Project) {
            throw new Error('LogStore and Project must both exist');
        }
        else if (definition.isLogConfigAuto(logConfig)) {
            if (!roleArn) {
                console.log('\tattaching police \'AliyunLogFullAccess\' to role: ' + roleName);
                yield attachPolicyToRole('AliyunLogFullAccess', roleName);
                console.log(green('\tattached police \'AliyunLogFullAccess\' to role: ' + roleName));
            }
        }
        return ((role || {}).Role || {}).Arn || roleArn || '';
    });
}
function hasConfiguration(tpl, configKey) {
    return _.findKey(tpl, item => {
        if (!_.isObject(item)) {
            return false;
        }
        if (Object.keys(item).includes(configKey)) {
            return true;
        }
        return hasConfiguration(item, configKey);
    });
}
function deployService({ baseDir, serviceName, serviceRes, onlyConfig, tplPath, skipTrigger = false, useNas, assumeYes }) {
    return __awaiter(this, void 0, void 0, function* () {
        const properties = (serviceRes.Properties || {});
        const internetAccess = 'InternetAccess' in properties ? properties.InternetAccess : null;
        const description = properties.Description;
        const vpcConfig = properties.VpcConfig;
        const nasConfig = properties.NasConfig;
        const logConfig = properties.LogConfig || {};
        const tracingConfig = properties.TracingConfig;
        const hasFunctionAsyncConfig = !!hasConfiguration(serviceRes, 'AsyncConfiguration');
        const hasCustomContainerConfig = !!hasConfiguration(serviceRes, 'CustomContainerConfig');
        const role = yield generateServiceRole({
            serviceName, vpcConfig, nasConfig, logConfig,
            roleArn: properties.Role,
            policies: properties.Policies,
            hasFunctionAsyncConfig,
            hasCustomContainerConfig
        });
        yield makeService({
            serviceName,
            role,
            internetAccess,
            description,
            logConfig,
            vpcConfig,
            nasConfig,
            tracingConfig
        });
        yield deployFunctions({ baseDir, serviceName, serviceRes, onlyConfig, tplPath, skipTrigger, useNas, assumeYes });
    });
}
function deployLogstoreDefaultIndex(projectName, logstoreName) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log(`\t\tWaiting for log service logstore ${logstoreName} default index to be deployed...`);
        yield makeLogstoreIndex(projectName, logstoreName);
        console.log(green(`\t\tlog service logstore ${logstoreName} default index deploy success`));
    });
}
function deployLogstore(projectName, logstoreDefinition) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const [logstoreName, v] of Object.entries(logstoreDefinition)) {
            if ((v || {}).Type === 'Aliyun::Serverless::Log::Logstore') {
                const properties = (v || {}).Properties;
                const ttl = properties.TTL;
                const shardCount = properties.ShardCount;
                console.log(`\tWaiting for log service logstore ${logstoreName} to be deployed...`);
                yield makeLogstore({
                    projectName,
                    logstoreName,
                    ttl,
                    shardCount
                });
                yield deployLogstoreDefaultIndex(projectName, logstoreName);
                console.log(green(`\tlog serivce logstore ${logstoreName} deploy success`));
            }
        }
    });
}
function sendHttpRequest(method, url, requestData) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield requestP({
            method,
            uri: url,
            body: requestData,
            json: true // Automatically stringifies the body to JSON
        });
    });
}
function convertRoutesConfigToRoutes(routeConfig) {
    const routes = [];
    for (const route of Object.entries(routeConfig)) {
        let deformedRoute = _.mapKeys(route[1], (value, key) => {
            return _.lowerFirst(key);
        });
        deformedRoute.path = route[0];
        routes.push(deformedRoute);
    }
    return routes;
}
function processTemporaryDomain(resources, { serviceName, functionName }, protocol) {
    return __awaiter(this, void 0, void 0, function* () {
        const profile = yield getProfile();
        const region = profile.defaultRegion;
        const accountId = profile.accountId;
        const tokenRs = yield sendHttpRequest('POST', TMP_DOMAIN_URL, { accountID: accountId, region });
        const token = tokenRs.token;
        const { functionRes } = definition.findFunctionByServiceAndFunctionName(resources, serviceName, functionName);
        if (_.isEmpty(functionRes)) {
            throw new Error(`could not found service/function：${serviceName}/${functionName}`);
        }
        const { tmpServiceName, tmpFunctionName, tmpTriggerName } = yield makeFcUtilsFunctionTmpDomainToken(token);
        const domainRs = yield sendHttpRequest('POST', TMP_DOMAIN_URL, { accountID: accountId, region, token });
        const domainName = domainRs.domain;
        yield deleteFunction(tmpServiceName, tmpFunctionName, tmpTriggerName);
        const { expiredTime, timesLimit, expiredTimeObj } = yield getTmpDomainExpiredTime(domainName);
        const currentTimestamp = Math.round(new Date().getTime() / 1000);
        if (expiredTime > currentTimestamp) {
            console.log(`The assigned temporary domain is ${yellow(parseProtocol(protocol, domainName))}，expired at ${yellow(date.format(expiredTimeObj, 'YYYY-MM-DD HH:mm:ss'))}, limited by ${yellow(timesLimit)} per day.`);
        }
        else {
            console.log(`The temporary domain ${yellow(parseProtocol(protocol, domainName))} of previous depoyment is expried.`);
        }
        return domainName;
    });
}
function getTmpDomainExpiredTime(domainName) {
    return __awaiter(this, void 0, void 0, function* () {
        const expiredTimeRs = yield sendHttpRequest('POST', TMP_DOMAIN_EXPIRED_TIME_URL, { domain: domainName });
        const expiredTime = expiredTimeRs.expired_time;
        const timesLimit = expiredTimeRs.times_limit;
        const expiredTimeObj = new Date(expiredTime * 1000);
        return {
            expiredTime,
            timesLimit,
            expiredTimeObj
        };
    });
}
function parseProtocol(protocol, domainName) {
    const resolveProtocol = protocol === 'HTTP' ? 'http://' : 'https://';
    return resolveProtocol + domainName;
}
function getReuseTmpDomainName(tplRoutes) {
    return __awaiter(this, void 0, void 0, function* () {
        const customDomains = yield listCustomDomains();
        const tmpDomains = customDomains.filter(f => {
            return _.endsWith(f.domainName, '.test.functioncompute.com');
        });
        if (_.isEmpty(tmpDomains)) {
            return null;
        }
        for (const tmpDomain of tmpDomains) {
            const routes = tmpDomain.routeConfig.routes;
            const tmpDomainName = tmpDomain.domainName;
            const protocol = tmpDomain.protocol;
            for (const route of routes) {
                for (const tplRoute of tplRoutes) {
                    if (tplRoute.serviceName === route.serviceName && tplRoute.functionName === route.functionName) {
                        const { expiredTime, timesLimit, expiredTimeObj } = yield getTmpDomainExpiredTime(tmpDomainName);
                        if (expiredTime > Math.round(new Date().getTime() / 1000)) {
                            console.log(`Fun will reuse the temporary domain ${yellow(parseProtocol(protocol, tmpDomainName))}, expired at ${yellow(date.format(expiredTimeObj, 'YYYY-MM-DD HH:mm:ss'))}, limited by ${yellow(timesLimit)} per day.\n`);
                            return tmpDomainName;
                        }
                    }
                }
            }
        }
        return null;
    });
}
function processTemporaryDomainIfNecessary(domainLogicId, domainDefinition, resources) {
    return __awaiter(this, void 0, void 0, function* () {
        const properties = (domainDefinition.Properties || {});
        const protocol = properties.Protocol;
        const realDomainName = properties.DomainName;
        const routesConfig = properties.RouteConfig.Routes || properties.RouteConfig.routes;
        const routes = convertRoutesConfigToRoutes(routesConfig);
        if (!realDomainName) {
            return {
                routes,
                domainName: domainLogicId
            };
        }
        if (realDomainName !== 'Auto') {
            return {
                routes,
                domainName: realDomainName
            };
        }
        console.log(yellow(`Detect 'DomainName:Auto' of custom domain '${domainLogicId}'`));
        const tmpDomainName = yield getReuseTmpDomainName(routes);
        if (tmpDomainName) {
            return {
                routes,
                domainName: tmpDomainName
            };
        }
        console.log(`Request a new temporary domain ...`);
        const domainName = yield processTemporaryDomain(resources, _.head(_.values(routes)), protocol);
        return {
            routes,
            domainName
        };
    });
}
function deployCustomDomain(domainName, domainDefinition, routes) {
    return __awaiter(this, void 0, void 0, function* () {
        const properties = (domainDefinition.Properties || {});
        const certConfig = properties.CertConfig || {};
        const protocol = properties.Protocol;
        if (_.isEmpty(certConfig) && protocol === 'HTTP,HTTPS') {
            throw new Error(red(`\nMust config "CertConfig" for CustomDomain "${domainName}" when using "HTTP,HTTPS" protocol.\nYou can refer to https://github.com/aliyun/fun/blob/master/docs/specs/2018-04-03-zh-cn.md#aliyunserverlesscustomdomain\nor https://github.com/aliyun/fun/blob/master/docs/specs/2018-04-03.md/#aliyunserverlesscustomdomain for help.`));
        }
        if (!_.isEmpty(certConfig) && protocol === 'HTTP') {
            throw new Error(red(`\nPlease don't use "CertConfig" config of CustomDomain "${domainName}" when using "HTTP" protocol.\nYou can refer to https://github.com/aliyun/fun/blob/master/docs/specs/2018-04-03-zh-cn.md#aliyunserverlesscustomdomain\nor https://github.com/aliyun/fun/blob/master/docs/specs/2018-04-03.md/#aliyunserverlesscustomdomain for help.`));
        }
        yield makeCustomDomain({ domainName, certConfig, protocol, routeConfig: { routes } });
    });
}
function deployLogs(resourcesDefinition) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const [projectName, v] of Object.entries(resourcesDefinition)) {
            if ((v || {}).Type === 'Aliyun::Serverless::Log') {
                console.log(`Waiting for log service project ${projectName} to be deployed...`);
                const properties = (v || {}).Properties;
                const description = properties.Description || '';
                yield makeSlsProject(projectName, description);
                yield deployLogstore(projectName, v);
                console.log(green(`log serivce project ${projectName} deploy success\n`));
            }
        }
    });
}
function deployTablestore(instanceName, resourceDefinition) {
    return __awaiter(this, void 0, void 0, function* () {
        const properties = (resourceDefinition || {}).Properties;
        if (properties) {
            const clusterType = (properties || {}).ClusterType;
            const description = (properties || {}).Description;
            yield makeOtsInstance(instanceName, clusterType, description);
        }
        for (const [k, v] of Object.entries(resourceDefinition)) {
            if ((v || {}).Type === 'Aliyun::Serverless::TableStore::Table') {
                console.log(`\tWaiting for table store ${k} to be created...`);
                yield makeOtsTable({
                    instanceName: instanceName,
                    tableName: k,
                    primaryKeys: (v.Properties || {}).PrimaryKeyList.map(i => ({
                        'name': i.Name,
                        'type': i.Type
                    }))
                });
                console.log(green(`\tcreate table store ${k} successfully`));
            }
        }
    });
}
function deployMNSTopic(topicName, topicDefinition) {
    return __awaiter(this, void 0, void 0, function* () {
        const properties = (topicDefinition || {}).Properties;
        if (properties === undefined) {
            console.error('MNSTopic resource properties must not be empty');
            return;
        }
        console.log(`\tWaiting for MNS topic ${topicName} to be deployed...`);
        yield makeMnsTopic(topicName, properties);
        console.log(green(`\tmns topic ${topicName} deploy success`));
    });
}
function evaluteExp(exp, ctx) {
    const match = /^\$\{(.+)\}$/.exec(exp);
    if (match) {
        if (match[1].endsWith('.Arn')) {
            return match[1].substring(0, match[1].length - '.Arn'.length);
        }
        return ctx[match[1]];
    }
    return exp;
}
function extractFcArn(arn) {
    const [, , , , path] = arn.split(':');
    const [, serviceName, , functionName] = path.split('/');
    return {
        serviceName: evaluteExp(serviceName),
        functionName: evaluteExp(functionName)
    };
}
function getSwagger(apiDefinition, tplPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const props = apiDefinition.Properties;
        if (props) {
            if (props.DefinitionBody) {
                return props.DefinitionBody;
            }
            else if (props.DefinitionUri) {
                var swaggerPath;
                if (path.isAbsolute(props.DefinitionUri)) {
                    swaggerPath = props.DefinitionUri;
                }
                else {
                    swaggerPath = path.join(path.dirname(tplPath), props.DefinitionUri);
                }
                const swaggerContent = yield fs.readFile(swaggerPath, 'utf8');
                return yaml.safeLoad(swaggerContent);
            }
        }
        else {
            return null;
        }
    });
}
function deployApigateway(name, { apiDefinition, template, tplPath }) {
    return __awaiter(this, void 0, void 0, function* () {
        const swaggerContent = yield getSwagger(apiDefinition, tplPath);
        if (swaggerContent) {
            for (const [k, v] of Object.entries(swaggerContent)) {
                if (!['openapi', 'info', 'components'].includes(k)) {
                    const apiGroup = yield makeGroup({
                        name,
                        description: `api group for function compute`
                    });
                    for (const [method, methodDefinition] of Object.entries(v)) {
                        const fcDefinition = methodDefinition['x-aliyun-apigateway-fc'];
                        let roleName;
                        if (fcDefinition.role) {
                            roleName = extractFcRole(fcDefinition.role);
                        }
                        else {
                            roleName = `AliyunFcGeneratedApiGatewayRole`;
                        }
                        const role = yield makeRole(roleName, true, 'API Gateway access FunctionCompute', {
                            'Statement': [{
                                    'Action': 'sts:AssumeRole',
                                    'Effect': 'Allow',
                                    'Principal': {
                                        'Service': [
                                            'apigateway.aliyuncs.com'
                                        ]
                                    }
                                }],
                            'Version': '1'
                        });
                        const policyName = 'AliyunFCInvocationAccess';
                        yield attachPolicyToRole(policyName, roleName);
                        debug('%j', role);
                        const apiName = methodDefinition['x-aliyun-apigateway-api-name'] || `${k.replace(/^\//, '').replace(/(\[|\])/g, '').replace(/\//g, '_')}_${method}`;
                        const { serviceName, functionName } = extractFcArn(fcDefinition.arn);
                        const serviceTimeout = fcDefinition.timeout || 3000;
                        const resultConfig = {
                            resultType: methodDefinition['x-aliyun-apigateway-result-type'],
                            resultSample: methodDefinition['x-aliyun-apigateway-result-sample'],
                            failResultSample: methodDefinition['x-aliyun-apigateway-fail-result-sample']
                        };
                        const requestConfig = methodDefinition['x-aliyun-apigateway-request-config'] || {};
                        let openIdConnectConfig = methodDefinition['x-aliyun-apigateway-open-id-connect-config'];
                        if (!openIdConnectConfig) {
                            openIdConnectConfig = methodDefinition['x-aliyun-apigateway-openid-connect-config'];
                        }
                        const requestParameters = methodDefinition['x-aliyun-apigateway-request-parameters'];
                        const serviceParameters = methodDefinition['x-aliyun-apigateway-service-parameters'];
                        const serviceParametersMap = methodDefinition['x-aliyun-apigateway-service-parameters-map'];
                        yield makeApi(apiGroup, {
                            stageName: apiDefinition.Properties.StageName,
                            requestPath: k,
                            method,
                            roleArn: role.Role.Arn,
                            apiName,
                            serviceName,
                            functionName,
                            serviceTimeout,
                            requestParameters,
                            serviceParameters,
                            serviceParametersMap,
                            auth: {
                                type: methodDefinition['x-aliyun-apigateway-auth-type'],
                                config: openIdConnectConfig
                            },
                            visibility: methodDefinition['x-aliyun-apigateway-visibility'],
                            requestConfig,
                            resultConfig,
                            description: methodDefinition['x-aliyun-apigateway-description'],
                            forceNonceCheck: methodDefinition['x-aliyun-apigateway-force-nonce-check'],
                            appCodeAuthType: methodDefinition['x-aliyun-apigateway-app-code-auth-type'],
                            allowSignatureMethod: methodDefinition['x-aliyun-apigateway-allow-signature-method'],
                            disableInternet: methodDefinition['x-aliyun-apigateway-disable-internet'],
                            webSocketApiType: methodDefinition['x-aliyun-apigateway-websocket-api-type'],
                            errorCodeSamples: methodDefinition['x-aliyun-apigateway-error-code-sample']
                        });
                    }
                }
            }
        }
    });
}
function partialDeployment(sourceName, tpl) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!sourceName) {
            return {};
        }
        const nameArray = sourceName.split('/');
        if (nameArray.length > 2) {
            throw new Error(`format error for local deployment: ` + red(`${sourceName}`) + `, the correct format is ` + green(`'serviceName/functionName' | 'serviceName' | 'functionName' | 'flowName'`));
        }
        if (nameArray.length === 2) {
            const funcRes = definition.findServiceByCertainServiceAndFunctionName(tpl.Resources, _.first(nameArray), _.last(nameArray));
            return {
                resourceName: funcRes.serviceName,
                resourceRes: funcRes.serviceRes
            };
        }
        else if (nameArray.length === 1) {
            const matchRes = yield definition.matchingResourceBySourceName(tpl.Resources, _.first(nameArray));
            return {
                resourceName: matchRes.resourceName,
                resourceRes: matchRes.resourceRes
            };
        }
        return {};
    });
}
function deployTplService({ baseDir, serviceName, serviceRes, onlyConfig, tplPath, useNas, assumeYes }) {
    return __awaiter(this, void 0, void 0, function* () {
        const beforeDeployLog = onlyConfig ? 'config to be updated' : 'to be deployed';
        const afterDeployLog = onlyConfig ? 'config update success' : 'deploy success';
        console.log(`Waiting for service ${serviceName} ${beforeDeployLog}...`);
        yield deployService({ baseDir, serviceName, serviceRes, onlyConfig, tplPath, useNas, assumeYes });
        console.log(green(`service ${serviceName} ${afterDeployLog}\n`));
    });
}
function deployFlow(name, resource, tpl, parameterOverride = {}, baseDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const properties = (resource.Properties || {});
        const description = properties.Description || '';
        let definition;
        if (properties.Definition) {
            definition = transformFlowDefinition(properties.Definition, tpl, parameterOverride);
        }
        else if (properties.DefinitionUri) {
            const definitionUri = path.resolve(baseDir, properties.DefinitionUri);
            const definitionObj = parseYamlWithCustomTag(properties.DefinitionUri, yield fs.readFile(definitionUri, 'utf8'));
            ({ definition } = transformFunctionInDefinition(definitionObj, tpl, parameterOverride));
        }
        else {
            throw new Error(`${name} should have Definition or DefinitionUri`);
        }
        const roleArn = properties.Role;
        const policies = properties.Policies;
        const profile = yield getProfile();
        const defaultRegion = profile.defaultRegion;
        let role;
        let roleName;
        if (!roleArn && policies) {
            roleName = `aliyunfnfgeneratedrole-${defaultRegion}-${name}`;
            roleName = normalizeRoleOrPoliceName(roleName);
            console.log(`\tmake sure role '${roleName}' is exist`);
            role = yield makeRole(roleName, true, 'Function Flow Default Role', FNF_ASSUME_ROLE_POLICY);
            console.log(green(`\trole '${roleName}' is already exist`));
            console.log('\tattaching policies ' + policies + ' to role: ' + roleName);
            yield deployPolicies(name, roleName, policies, 'FnF');
            console.log(green('\tattached policies ' + policies + ' to role: ' + roleName));
        }
        yield makeFlow({
            name,
            definition,
            description,
            roleArn: ((role || {}).Role || {}).Arn || roleArn
        });
    });
}
function fetchRemoteYml(baseDir, tpl) {
    return __awaiter(this, void 0, void 0, function* () {
        const importTmpDir = path.join(baseDir, '.fun', 'tmp', 'deploy');
        const importYmlPath = path.join(importTmpDir, 'template.yml');
        yield fs.ensureDir(importTmpDir);
        yield fs.remove(importYmlPath);
        const services = definition.findServices(tpl.Resources);
        console.log('Collecting your services information, in order to caculate devlopment changes...');
        for (const service of services) {
            const originConsoleLog = console.log;
            console.log = debug;
            try {
                yield importService(service.serviceName, importTmpDir, true, true, true);
            }
            catch (e) {
                debug('import service error', e);
            }
            console.log = originConsoleLog;
        }
        if (!(yield fs.pathExists(importYmlPath))) {
            return {
                Resources: {}
            };
        }
        return yield getTpl(importYmlPath);
    });
}
function deployByApi(baseDir, tpl, tplPath, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const remoteYml = yield fetchRemoteYml(baseDir, tpl);
        const { resourceName, resourceRes } = yield partialDeployment(context.resourceName, tpl);
        if (resourceName) {
            const { Type: resourceType = '' } = resourceRes;
            if (resourceType === definition.SERVICE_RESOURCE) {
                yield showResourcesChanges({ Resources: { [resourceName]: resourceRes } }, remoteYml);
                if (!context.assumeYes && !(yield promptForConfirmContinue('Please confirm to continue.'))) {
                    return;
                }
                yield deployTplService({ baseDir, tplPath,
                    serviceName: resourceName,
                    serviceRes: resourceRes,
                    useNas: context.useNas,
                    onlyConfig: context.onlyConfig
                });
            }
            else if (resourceType === definition.FLOW_RESOURCE) {
                yield deployFlow(resourceName, resourceRes, tpl, context.parameterOverride, baseDir);
            }
            else {
                throw new Error(`${resourceName} can not be partial deploy`);
            }
            return;
        }
        yield showResourcesChanges(tpl, remoteYml);
        if (!context.assumeYes && !(yield promptForConfirmContinue('Please confirm to continue.'))) {
            return;
        }
        yield deployLogs(tpl.Resources);
        for (const [name, resource] of Object.entries(tpl.Resources)) {
            if (resource.Type === 'Aliyun::Serverless::Service') {
                yield deployTplService({ baseDir, tplPath,
                    serviceName: name,
                    serviceRes: resource,
                    useNas: context.useNas,
                    onlyConfig: context.onlyConfig,
                    assumeYes: context.assumeYes
                });
            }
            else if (resource.Type === 'Aliyun::Serverless::Api') {
                console.log(`Waiting for api gateway ${name} to be deployed...`);
                yield deployApigateway(name, {
                    apiDefinition: resource,
                    template: tpl,
                    tplPath
                });
                console.log(green(`api gateway ${name} deploy success\n`));
            }
            else if (resource.Type === 'Aliyun::Serverless::TableStore') {
                console.log(`Waiting for table store ${name} to be deployed...`);
                yield deployTablestore(name, resource);
                console.log(green(`table store ${name} deploy success\n`));
            }
            else if (resource.Type === 'Aliyun::Serverless::Log') {
                // ignore, done by deployLogs
            }
            else if (resource.Type === 'Aliyun::Serverless::CustomDomain') {
                const { domainName, routes } = yield processTemporaryDomainIfNecessary(name, resource, tpl.Resources);
                console.log(`Waiting for custom domain ${name} to be deployed...`);
                yield deployCustomDomain(domainName, resource, routes);
                console.log(green(`custom domain ${name} deploy success\n`));
            }
            else if (resource.Type === 'Aliyun::Serverless::MNSTopic') {
                console.log(`Waiting for Mns topic ${name} to be deployed...`);
                yield deployMNSTopic(name, resource);
                console.log(green(`table store ${name} deploy success\n`));
            }
            else if (resource.Type === 'Aliyun::Serverless::Flow') {
                console.log(`Waiting for flow ${name} to be deployed...`);
                yield deployFlow(name, resource, tpl, context.parameterOverride, baseDir);
                console.log(green(`flow ${name} deploy success\n`));
            }
            else {
                console.log('unknown resource %s', name);
            }
        }
    });
}
function deploy(tplPath, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!context.useRos) {
            yield validate(tplPath);
        }
        else {
            // todo: ValidateTemplate
            // https://api.aliyun.com/#/?product=ROS&api=ValidateTemplate&tab=DEMO&lang=NODEJS
        }
        const tpl = yield getTpl(tplPath);
        const profile = yield getProfile();
        if (context.pushRegistry) {
            yield getFunctionImage({ tpl, region: profile.defaultRegion, pushRegistry: context.pushRegistry });
        }
        console.log(`using region: ${profile.defaultRegion}`);
        console.log(`using accountId: ${mark(profile.accountId)}`);
        console.log(`using accessKeyId: ${mark(profile.accessKeyId)}`);
        console.log(`using timeout: ${profile.timeout}\n`);
        const baseDir = path.resolve(tplPath, '..');
        const dirName = path.basename(baseDir);
        const DEFAULT_STACK_NAME = `fun_default_stack_for_${dirName}`;
        if (context.useRos) {
            if (context.stackName) {
                console.log(yellow(`deploying by ROS, The Stack name is ${context.stackName}`));
            }
            else {
                console.log(yellow(`missing --stack-name parameter, using default stackName '${dirName}'`));
            }
            const stackName = context.stackName || DEFAULT_STACK_NAME;
            yield deployByRos(baseDir, stackName, tpl, context.assumeYes, context.parameterOverride, tplPath);
        }
        else {
            yield deployByApi(baseDir, tpl, tplPath, context);
            const serviceNasMappings = yield getNasMappingsFromNasYml(getNasYmlPath(tplPath));
            showTipsForNasYml(getRootBaseDir(baseDir), serviceNasMappings);
        }
    });
}
module.exports = {
    deploy, deployCustomDomain,
    partialDeployment, deployService, deployByApi
};
