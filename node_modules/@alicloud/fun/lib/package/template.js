'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fc = require('../fc');
const fnf = require('../fnf');
const fs = require('fs-extra');
const path = require('path');
const util = require('./util');
const zip = require('../package/zip');
const definition = require('../definition');
const bytes = require('bytes');
const { getTpl } = require('../tpl');
const { green, yellow } = require('colors');
const { generateRandomZipPath } = require('../utils/path');
const { generateNasPythonPaths, mergeEnvs } = require('../../lib/install/env');
const { processOSSBucket } = require('../oss');
const { getOssClient } = require('../client');
const { isCustomContainerRuntime } = require('../common/model/runtime');
const _ = require('lodash');
function generateRosTemplateForNasConfig(serviceName, userId, groupId) {
    return {
        'UserId': userId,
        'GroupId': groupId,
        'MountPoints': [
            {
                'ServerAddr': {
                    'Fn::Join': [
                        '',
                        [
                            {
                                'Ref': 'MountTarget'
                            },
                            ':/',
                            serviceName
                        ]
                    ]
                },
                'MountDir': '/mnt/auto'
            }
        ]
    };
}
function generateRosTemplateForVpcConfig() {
    return {
        'VpcId': {
            'Ref': 'Vpc'
        },
        'VSwitchIds': [
            {
                'Ref': 'VSwitch'
            }
        ],
        'SecurityGroupId': {
            'Ref': 'SecurityGroup'
        }
    };
}
function generateRosTemplateForDefaultResources(serviceNames, hasNasCpRes) {
    const dependsOnRoles = [...serviceNames.map(serviceName => `AliyunECSNetworkInterfaceManagementAccess${serviceName}Role`)];
    if (hasNasCpRes) {
        dependsOnRoles.push('AliyunECSNetworkInterfaceManagementAccessNasRole');
    }
    return {
        'Vpc': {
            'Type': 'ALIYUN::ECS::VPC',
            'Properties': {
                'Description': 'used for FC Application Repository',
                'CidrBlock': '10.0.0.0/8',
                'VpcName': {
                    'Ref': 'ALIYUN::StackName'
                }
            }
        },
        'SecurityGroup': {
            'Type': 'ALIYUN::ECS::SecurityGroup',
            'DependsOn': dependsOnRoles,
            'Properties': {
                'SecurityGroupName': {
                    'Ref': 'ALIYUN::StackName'
                },
                'VpcId': {
                    'Ref': 'Vpc'
                }
            }
        },
        'VSwitch': {
            'Type': 'ALIYUN::ECS::VSwitch',
            'Properties': {
                'ZoneId': {
                    'Fn::FindInMap': [
                        'RegionMap',
                        {
                            'Ref': 'ALIYUN::Region'
                        },
                        'ZoneId'
                    ]
                },
                'VpcId': {
                    'Ref': 'Vpc'
                },
                'CidrBlock': '10.20.0.0/16'
            }
        },
        'FileSystem': {
            'Type': 'ALIYUN::NAS::FileSystem',
            'Properties': {
                'StorageType': 'Performance',
                'Description': 'used_for_fun',
                'ProtocolType': 'NFS'
            }
        },
        'MountTarget': {
            'Type': 'ALIYUN::NAS::MountTarget',
            'Properties': {
                'Status': 'Active',
                'VpcId': {
                    'Ref': 'Vpc'
                },
                'NetworkType': 'Vpc',
                'VSwitchId': {
                    'Ref': 'VSwitch'
                },
                'AccessGroupName': 'DEFAULT_VPC_GROUP_NAME',
                'FileSystemId': {
                    'Ref': 'FileSystem'
                }
            }
        }
    };
}
function generateRosTemplateForWaitCondition(count) {
    return {
        'WaitCondition': {
            'Type': 'ALIYUN::ROS::WaitCondition',
            'Properties': {
                'Count': count,
                'Handle': {
                    'Ref': 'WaitConHandle'
                },
                'Timeout': 600
            },
            'DependsOn': 'Nas'
        },
        'WaitConHandle': {
            'Type': 'ALIYUN::ROS::WaitConditionHandle',
            'Properties': {
                'Mode': 'Full',
                'Count': -1
            }
        }
    };
}
function generateRosTemplateForNasService(ossCodeUri) {
    return {
        'Nas': {
            'Type': 'Aliyun::Serverless::Service',
            'Properties': {
                'Description': 'download dependences from oss and upload to nas.',
                'Policies': [
                    'AliyunOssFullAccess'
                ],
                'VpcConfig': {
                    'VpcId': {
                        'Ref': 'Vpc'
                    },
                    'VSwitchIds': [
                        {
                            'Ref': 'VSwitch'
                        }
                    ],
                    'SecurityGroupId': {
                        'Ref': 'SecurityGroup'
                    }
                },
                'NasConfig': {
                    'UserId': 10003,
                    'GroupId': 10003,
                    'MountPoints': [
                        {
                            'ServerAddr': {
                                'Fn::Join': [
                                    '',
                                    [
                                        {
                                            'Ref': 'MountTarget'
                                        },
                                        ':/'
                                    ]
                                ]
                            },
                            'MountDir': '/mnt/nas_dependencies'
                        }
                    ]
                }
            },
            'NasCpFunc': {
                'Type': 'Aliyun::Serverless::Function',
                'Properties': {
                    'Handler': 'index.cpFromOssToNasHandler',
                    'Runtime': 'nodejs8',
                    'CodeUri': ossCodeUri,
                    'MemorySize': 3072,
                    'Timeout': 300
                }
            }
        }
    };
}
function generateRosTemplateForNasCpInvoker(serviceName, bucketName, objectNames) {
    return {
        [`${serviceName}-NasCpInvoker`]: {
            'Type': 'ALIYUN::FC::FunctionInvoker',
            'DependsOn': 'MountTarget',
            'Properties': {
                'FunctionName': {
                    'Fn::GetAtt': [
                        'NasNasCpFunc',
                        'FunctionName'
                    ]
                },
                'ServiceName': {
                    'Fn::GetAtt': [
                        'Nas',
                        'ServiceName'
                    ]
                },
                'Event': {
                    'Fn::Join': [
                        '',
                        [
                            `{"dst": "/mnt/nas_dependencies/`,
                            serviceName,
                            '", "bucket": "',
                            bucketName,
                            `", "objectNames": ${JSON.stringify(objectNames)}, "rosCurl": "`,
                            {
                                'Fn::GetAtt': [
                                    'WaitConHandle',
                                    'CurlCli'
                                ]
                            },
                            `"}`
                        ]
                    ]
                },
                'Async': true,
                'ExecuteVersion': 1
            }
        }
    };
}
function generateRosTemplateForDefaultOutputs() {
    return {
        'Outputs': {
            'CurlCli': {
                'Value': {
                    'Fn::GetAtt': [
                        'WaitConHandle',
                        'CurlCli'
                    ]
                }
            },
            'Data': {
                'Value': {
                    'Fn::GetAtt': [
                        'WaitCondition',
                        'Data'
                    ]
                }
            },
            'ErrorData': {
                'Value': {
                    'Fn::GetAtt': [
                        'WaitCondition',
                        'ErrorData'
                    ]
                }
            }
        }
    };
}
function generateRosTemplateForEventOutputs(bucketName, objectNames, serviceName) {
    return {
        'Outputs': {
            [`${serviceName}-Event`]: {
                'Description': 'function invoke event',
                'Value': {
                    'Fn::Join': [
                        '',
                        [
                            `{"dst": "/mnt/nas_dependencies/`,
                            serviceName,
                            '", "bucket": "',
                            bucketName,
                            `", "objectNames": ${JSON.stringify(objectNames)}, "rosCurl": "`,
                            {
                                'Fn::GetAtt': [
                                    'WaitConHandle',
                                    'CurlCli'
                                ]
                            },
                            `"}`
                        ]
                    ]
                }
            }
        }
    };
}
function generateRosTemplateForRegionMap() {
    return {
        'Mappings': {
            'RegionMap': {
                'cn-shanghai': {
                    'ZoneId': 'cn-shanghai-e'
                },
                'cn-hangzhou': {
                    'ZoneId': 'cn-hangzhou-g'
                },
                'cn-qingdao': {
                    'ZoneId': 'cn-qingdao-c'
                },
                'cn-beijing': {
                    'ZoneId': 'cn-beijing-c'
                },
                'cn-zhangjiakou': {
                    'ZoneId': 'cn-zhangjiakou-b'
                },
                'cn-huhehaote': {
                    'ZoneId': 'cn-huhehaote-a'
                },
                'cn-shenzhen': {
                    'ZoneId': 'cn-shenzhen-d'
                },
                'cn-hongkong': {
                    'ZoneId': 'cn-hongkong-c'
                },
                'ap-southeast-1': {
                    'ZoneId': 'ap-southeast-1a'
                },
                'ap-southeast-2': {
                    'ZoneId': 'ap-southeast-2a'
                },
                'ap-southeast-5': {
                    'ZoneId': 'ap-southeast-5a'
                },
                'ap-northeast-1': {
                    'ZoneId': 'ap-northeast-1a'
                },
                'eu-central-a': {
                    'ZoneId': 'eu-central-a'
                },
                'us-west-1': {
                    'ZoneId': 'us-west-1a'
                },
                'us-east-1': {
                    'ZoneId': 'us-east-1a'
                },
                'cn-chengdu': {
                    'ZoneId': 'cn-chengdu-a'
                },
                'ap-southeast-3': {
                    'ZoneId': 'ap-southeast-3a'
                },
                'eu-west-1': {
                    'ZoneId': 'eu-west-1a'
                },
                'eu-central-1': {
                    'ZoneId': 'eu-central-a'
                },
                'ap-south-1': {
                    'ZoneId': 'ap-south-1a'
                }
            }
        }
    };
}
function generateServiceLogConfig(projectName, logstoreName) {
    return {
        'Project': {
            'Fn::GetAtt': [
                projectName,
                'Name'
            ]
        },
        'Logstore': logstoreName
    };
}
function generateRosTemplateForSLS(projectName, logstoreName) {
    return {
        [projectName]: {
            'Type': 'Aliyun::Serverless::Log',
            'Properties': {
                'Description': 'create by fun.',
                'Policies': [
                    'AliyunLogFullAccess'
                ]
            },
            [logstoreName]: {
                'Type': 'Aliyun::Serverless::Log::Logstore',
                'Properties': {
                    'TTL': 10,
                    'ShardCount': 1
                }
            }
        },
        'functionLogIndex': {
            'Type': 'ALIYUN::SLS::Index',
            'Properties': {
                'ProjectName': {
                    'Fn::GetAtt': [
                        projectName,
                        'Name'
                    ]
                },
                'FullTextIndex': {
                    'Enable': true,
                    'IncludeChinese': true
                },
                'LogstoreName': logstoreName
            },
            'DependsOn': [projectName, `${projectName}${logstoreName}`]
        }
    };
}
const { parseYamlWithCustomTag } = require('../parse');
function isOssUrl(url) {
    if (_.isEmpty(url)) {
        return false;
    }
    return url.startsWith('oss://');
}
function checkZipCodeExist(client, objectName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield client.head(objectName);
            return true;
        }
        catch (e) {
            if (e.name === 'NoSuchKeyError') {
                return false;
            }
            throw e;
        }
    });
}
function uploadToOss({ ossClient, zipPath, count, compressedSize, srcPath, tplPath }) {
    return __awaiter(this, void 0, void 0, function* () {
        const objectName = yield util.md5(zipPath);
        yield copyToLocalPackagePath({ tplPath, zipPath, objectName });
        const exist = yield checkZipCodeExist(ossClient, objectName);
        if (!exist) {
            yield ossClient.put(objectName, fs.createReadStream(zipPath));
            const convertedSize = bytes(compressedSize, {
                unitSeparator: ' '
            });
            let log = '';
            if (count) {
                log = `\nA total of ` + yellow(`${count}`) + `${count === 1 ? ' file' : ' files'}` + ` files were compressed and the final size was` + yellow(` ${convertedSize}`);
            }
            console.log(green(`\n${srcPath} has been uploaded to OSS. objectName: ${objectName}.${log}`));
        }
        else {
            console.log(`\n${srcPath} has been uploaded to OSS, skiping.`);
        }
        return objectName;
    });
}
function zipCode(srcPath, ignore, zipName = 'code.zip', prefix, zlibOptions = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { randomDir, zipPath } = yield generateRandomZipPath(zipName);
        const { count, compressedSize } = yield zip.packTo(srcPath, ignore, zipPath, prefix, zlibOptions);
        return {
            zipPath,
            randomDir,
            count,
            compressedSize
        };
    });
}
function zipCodeToOss({ ossClient, codeUri, runtime, ignore, tplPath, nasConfig, serviceName, functionName, zipName = 'code.zip', prefix = '', useNas = false, isRosCodeUri = false, zlibOptions = {} }) {
    return __awaiter(this, void 0, void 0, function* () {
        let objectName;
        if (codeUri.endsWith('.zip') || codeUri.endsWith('.jar') || codeUri.endsWith('.war')) {
            const stat = yield fs.stat(codeUri);
            objectName = yield uploadToOss({ ossClient,
                zipPath: codeUri,
                compressedSize: stat.size,
                srcPath: codeUri,
                tplPath
            });
            return { objectName };
        }
        const { zipPath, randomDir, count, compressedSize } = yield zipCode(codeUri, ignore, zipName, prefix, zlibOptions);
        if (count === 0) {
            return { isEmpty: true, objectName };
        }
        const rs = yield fc.nasAutoConfigurationIfNecessary({ stage: 'package', tplPath, compressedSize, useNas,
            nasConfig, runtime, codeUri,
            isRosCodeUri,
            nasServiceName: serviceName,
            nasFunctionName: functionName
        });
        if (!rs.stop) {
            objectName = yield uploadToOss({ ossClient, zipPath,
                srcPath: codeUri,
                compressedSize, count, tplPath
            });
        }
        yield fs.remove(randomDir);
        return {
            stop: rs.stop,
            objectName
        };
    });
}
function uploadNasService(ossClient, tplPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const zipCodePath = path.resolve(__dirname, '../utils/fun-nas-server/dist/fun-nas-server.zip');
        if (!(yield fs.pathExists(zipCodePath))) {
            throw new Error('could not find ../utils/fun-nas-server/dist/fun-nas-server.zip');
        }
        const stat = yield fs.stat(zipCodePath);
        const objectName = yield uploadToOss({ ossClient,
            zipPath: zipCodePath,
            srcPath: zipCodePath,
            compressedSize: stat.size,
            tplPath
        });
        return `oss://${ossClient.options.bucket}/${objectName}`;
    });
}
function zipToOss(ossClient, srcPath, ignore, zipName = 'code.zip', prefix = '', tplPath, zlibOptions = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { randomDir, zipPath } = yield generateRandomZipPath(zipName);
        const { count, compressedSize } = yield zip.packTo(srcPath, ignore, zipPath, prefix, zlibOptions);
        if (count === 0) {
            return null;
        }
        const objectName = yield util.md5(zipPath);
        yield copyToLocalPackagePath({ tplPath, zipPath, objectName });
        const exist = yield checkZipCodeExist(ossClient, objectName);
        if (!exist) {
            yield ossClient.put(objectName, fs.createReadStream(zipPath));
            const convertedSize = bytes(compressedSize, {
                unitSeparator: ' '
            });
            console.log(green(`\n${srcPath} has been uploaded to OSS. objectName: ${objectName}. A total of ` + yellow(`${count}`) + `${count === 1 ? ' file' : ' files'}` + ` files were compressed and the final size was` + yellow(` ${convertedSize}`)));
        }
        else {
            console.log(`\n${srcPath} has been uploaded to OSS, skiping.`);
        }
        yield fs.remove(randomDir);
        return objectName;
    });
}
function copyToLocalPackagePath({ tplPath, zipPath, objectName }) {
    return __awaiter(this, void 0, void 0, function* () {
        const dstPath = path.resolve(path.dirname(tplPath), '.fun', 'package', objectName);
        if (yield fs.pathExists(dstPath)) {
            return;
        }
        yield fs.copy(zipPath, dstPath);
    });
}
function processNasPythonPaths(tpl, tplPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const updatedTplContent = _.cloneDeep(tpl);
        for (const { serviceRes } of definition.findServices(updatedTplContent.Resources)) {
            const nasConfig = (serviceRes.Properties || {}).NasConfig;
            if (_.isEmpty(nasConfig)) {
                continue;
            }
            const nasEnv = generateNasPythonPaths(nasConfig);
            for (const { functionRes } of definition.findFunctions(serviceRes)) {
                if (!_.includes(['python2.7', 'python3'], functionRes.Properties.Runtime)) {
                    continue;
                }
                functionRes.Properties.EnvironmentVariables = mergeEnvs(functionRes, nasEnv);
            }
        }
        return updatedTplContent;
    });
}
function uploadAndUpdateFunctionCode({ tpl, tplPath, useNas, baseDir, ossClient }) {
    return __awaiter(this, void 0, void 0, function* () {
        let updatedTplContent = _.cloneDeep(tpl);
        let processed;
        let zlibOptions = {};
        do {
            if (processed) {
                console.log(yellow(`\nFun will execute the ‘fun package’ again.`));
            }
            processed = false;
            const codeUriCache = new Map();
            for (const { serviceName, serviceRes, functionName, functionRes } of definition.findFunctionsInTpl(updatedTplContent)) {
                const runtime = (functionRes.Properties || {}).Runtime;
                if (isCustomContainerRuntime(runtime)) {
                    delete (functionRes.Properties || {}).CodeUri;
                    continue;
                }
                if (isOssUrl((functionRes.Properties || {}).CodeUri)) {
                    continue;
                }
                const codeUri = (functionRes.Properties || {}).CodeUri;
                const absCodeUri = path.resolve(baseDir, codeUri);
                if (!(yield fs.pathExists(absCodeUri))) {
                    throw new Error(`codeUri ${absCodeUri} is not exist`);
                }
                if (codeUriCache.get(absCodeUri)) {
                    functionRes.Properties.CodeUri = codeUriCache.get(absCodeUri);
                    continue;
                }
                const ignore = yield fc.generateFunIngore(baseDir, codeUri);
                const rs = yield zipCodeToOss({
                    ossClient, codeUri: absCodeUri, runtime, ignore, tplPath, useNas,
                    serviceName, functionName, nasConfig: (serviceRes.Properties || {}).NasConfig,
                    zlibOptions
                });
                if (!rs.objectName && rs.isEmpty) {
                    throw new Error(`code.zip for Codeuri ${codeUri} could not be empty.`);
                }
                if (rs.stop) {
                    processed = true;
                    useNas = false;
                    zlibOptions.level = 1;
                    updatedTplContent = yield getTpl(tplPath);
                    break;
                }
                const resolveCodeUri = `oss://${ossClient.options.bucket}/${rs.objectName}`;
                functionRes.Properties.CodeUri = resolveCodeUri;
                codeUriCache.set(absCodeUri, resolveCodeUri);
            }
        } while (processed);
        return updatedTplContent;
    });
}
function transformFlowDefinition(baseDir, tpl) {
    return __awaiter(this, void 0, void 0, function* () {
        const updatedTplContent = _.cloneDeep(tpl);
        const flowsNeedTransform = [];
        definition.iterateResources(updatedTplContent.Resources, definition.FLOW_RESOURCE, (flowName, flowRes) => {
            const { Properties: flowProperties = {} } = flowRes;
            if (!flowProperties.DefinitionUri && !flowProperties.Definition) {
                throw new Error(`${flowName} should have DefinitionUri or Definition`);
            }
            if (!flowProperties.Definition) {
                flowsNeedTransform.push(flowRes);
            }
        });
        const definitionCache = new Map();
        for (const flowRes of flowsNeedTransform) {
            const { Properties: flowProperties } = flowRes;
            const definitionUri = flowProperties.DefinitionUri;
            const absDefinitionUri = path.resolve(baseDir, definitionUri);
            if (!(yield fs.pathExists(absDefinitionUri))) {
                throw new Error(`DefinitionUri ${absDefinitionUri} is not exist`);
            }
            if (definitionCache.get(absDefinitionUri)) {
                flowProperties.Definition = definitionCache.get(absDefinitionUri);
                continue;
            }
            const definitionObj = parseYamlWithCustomTag(absDefinitionUri, fs.readFileSync(absDefinitionUri, 'utf8'));
            const { definition, dependsOn } = fnf.transformFunctionInDefinition(definitionObj, tpl, {}, true);
            delete flowProperties.DefinitionUri;
            flowProperties.Definition = {
                'Fn::Sub': definition
            };
            flowRes.DependsOn = dependsOn;
            definitionCache.set(absDefinitionUri, definition);
        }
        return updatedTplContent;
    });
}
function transformRosYmlCodeUri({ baseDir, tpl, tplPath, bucketName, ossClient }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!ossClient) {
            bucketName = yield processOSSBucket();
            ossClient = yield getOssClient(bucketName);
        }
        for (const key of Object.keys(tpl.Resources)) {
            const { Type, Properties: properties } = tpl.Resources[key];
            if (Type === 'ALIYUN::FC::Function' && !isCustomContainerRuntime(properties.Runtime) && !properties.Code) {
                if (!properties.CodeUri) {
                    throw new Error(`ALIYUN::FC::Function Code is empty.`);
                }
                const ignore = yield fc.generateFunIngore(baseDir, properties.CodeUri);
                const oss = yield zipCodeToOss({
                    tplPath,
                    ignore,
                    ossClient,
                    codeUri: properties.CodeUri,
                    runtime: properties.Runtime,
                    isRosCodeUri: true
                });
                if (!oss.objectName) {
                    throw new Error(`Codeuri ${properties.CodeUri} upload to oss error.`);
                }
                tpl.Resources[key].Properties.Code = {
                    OssBucketName: bucketName,
                    OssObjectName: oss.objectName
                };
                delete tpl.Resources[key].Properties.CodeUri;
            }
        }
        return tpl;
    });
}
module.exports = {
    zipToOss,
    zipCodeToOss,
    transformRosYmlCodeUri,
    uploadNasService,
    processNasPythonPaths,
    transformFlowDefinition,
    generateServiceLogConfig,
    generateRosTemplateForSLS,
    uploadAndUpdateFunctionCode,
    generateRosTemplateForRegionMap,
    generateRosTemplateForNasConfig,
    generateRosTemplateForVpcConfig,
    generateRosTemplateForNasService,
    generateRosTemplateForNasCpInvoker,
    generateRosTemplateForEventOutputs,
    generateRosTemplateForWaitCondition,
    generateRosTemplateForDefaultOutputs,
    generateRosTemplateForDefaultResources
};
