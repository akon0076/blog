'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const definition = require('../definition');
const docker = require('../docker');
const dockerOpts = require('../docker-opts');
const debug = require('debug')('fun:local');
const path = require('path');
const fs = require('fs-extra');
const rimraf = require('rimraf');
const extract = require('extract-zip');
const tmpDir = require('temp-dir');
const uuid = require('uuid');
const { DEFAULT_NAS_PATH_SUFFIX } = require('../tpl');
const { isCustomContainerRuntime } = require('../common/model/runtime');
const _ = require('lodash');
function isZipArchive(codeUri) {
    return codeUri ? codeUri.endsWith('.zip') || codeUri.endsWith('.jar') || codeUri.endsWith('.war') : false;
}
function processZipCodeIfNecessary(codeUri) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isZipArchive(codeUri)) {
            return null;
        }
        const tmpCodeDir = path.join(tmpDir, uuid.v4());
        yield fs.ensureDir(tmpCodeDir);
        console.log(`codeUri is a zip format, will unzipping to ${tmpCodeDir}`);
        return yield new Promise((resolve, reject) => {
            // use extract-zip instead of unzipper  https://github.com/alibaba/funcraft/issues/756
            extract(codeUri, { dir: tmpCodeDir }, (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(tmpCodeDir);
            });
        });
    });
}
class Invoke {
    constructor(serviceName, serviceRes, functionName, functionRes, debugPort, debugIde, baseDir, tmpDir, debuggerPath, debugArgs, nasBaseDir) {
        this.serviceName = serviceName;
        this.serviceRes = serviceRes;
        this.functionName = functionName;
        this.functionRes = functionRes;
        this.functionProps = functionRes.Properties;
        this.debugPort = debugPort;
        this.debugIde = debugIde;
        this.nasBaseDir = nasBaseDir;
        this.runtime = this.functionProps.Runtime;
        this.baseDir = baseDir;
        this.codeUri = this.functionProps.CodeUri ? path.resolve(this.baseDir, this.functionProps.CodeUri) : null;
        this.tmpDir = tmpDir;
        this.debuggerPath = debuggerPath;
        this.debugArgs = debugArgs;
    }
    invoke() {
        return __awaiter(this, arguments, void 0, function* () {
            if (!this.inited) {
                yield this.init();
            }
            yield this.beforeInvoke();
            yield this.showDebugIdeTips();
            yield this.doInvoke(...arguments);
            yield this.afterInvoke();
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.nasConfig = definition.findNasConfigInService(this.serviceRes);
            this.dockerUser = yield dockerOpts.resolveDockerUser({ nasConfig: this.nasConfig });
            this.nasMounts = yield docker.resolveNasConfigToMounts(this.baseDir, this.serviceName, this.nasConfig, this.nasBaseDir || path.join(this.baseDir, DEFAULT_NAS_PATH_SUFFIX));
            this.unzippedCodeDir = yield processZipCodeIfNecessary(this.codeUri);
            this.codeMount = yield docker.resolveCodeUriToMount(this.unzippedCodeDir || this.codeUri);
            this.nasMappingsMount = yield docker.resolveNasYmlToMount(this.baseDir, this.serviceName);
            this.tmpDirMount = yield docker.resolveTmpDirToMount(this.tmpDir);
            this.debuggerMount = yield docker.resolveDebuggerPathToMount(this.debuggerPath);
            this.passwdMount = yield docker.resolvePasswdMount();
            const allMount = _.compact([this.codeMount, ...this.nasMounts, ...this.nasMappingsMount, this.passwdMount]);
            if (!_.isEmpty(this.tmpDirMount)) {
                allMount.push(this.tmpDirMount);
            }
            if (!_.isEmpty(this.debuggerMount)) {
                allMount.push(this.debuggerMount);
            }
            const isDockerToolBox = yield docker.isDockerToolBoxAndEnsureDockerVersion();
            if (isDockerToolBox) {
                this.mounts = dockerOpts.transformMountsForToolbox(allMount);
            }
            else {
                this.mounts = allMount;
            }
            debug(`docker mounts: %s`, JSON.stringify(this.mounts, null, 4));
            this.containerName = docker.generateRamdomContainerName();
            const isCustomContainer = isCustomContainerRuntime(this.runtime);
            if (isCustomContainer) {
                this.imageName = this.functionProps.CustomContainerConfig.Image;
            }
            else {
                this.imageName = yield dockerOpts.resolveRuntimeToDockerImage(this.runtime);
            }
            yield docker.pullImageIfNeed(this.imageName);
            this.inited = true;
        });
    }
    beforeInvoke() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    showDebugIdeTips() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debugPort && this.debugIde) {
                // not show tips if debugIde is null
                if (this.debugIde === 'vscode') {
                    yield docker.showDebugIdeTipsForVscode(this.serviceName, this.functionName, this.runtime, this.codeMount.Source, this.debugPort);
                }
                else if (this.debugIde === 'pycharm') {
                    yield docker.showDebugIdeTipsForPycharm(this.codeMount.Source, this.debugPort);
                }
            }
        });
    }
    cleanUnzippedCodeDir() {
        if (this.unzippedCodeDir) {
            rimraf.sync(this.unzippedCodeDir);
            console.log(`clean tmp code dir ${this.unzippedCodeDir} successfully`);
            this.unzippedCodeDir = null;
        }
    }
    afterInvoke() {
        return __awaiter(this, void 0, void 0, function* () {
            this.cleanUnzippedCodeDir();
        });
    }
}
module.exports = Invoke;
