'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const Invoke = require('./invoke');
const docker = require('../docker');
const dockerOpts = require('../docker-opts');
const debug = require('debug')('fun:local');
class EventStart extends Invoke {
    constructor(serviceName, serviceRes, functionName, functionRes, debugPort, debugIde, baseDir, tmpDir, debuggerPath, debugArgs, nasBaseDir) {
        super(serviceName, serviceRes, functionName, functionRes, debugPort, debugIde, baseDir, tmpDir, debuggerPath, debugArgs, nasBaseDir);
    }
    init() {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.init.call(this);
            this.envs = yield docker.generateDockerEnvs(this.baseDir, this.serviceName, this.serviceRes.Properties, this.functionName, this.functionProps, this.debugPort, null, this.nasConfig, false, this.debugIde, this.debugArgs);
            this.containerName = dockerOpts.generateContainerName(this.serviceName, this.functionName, this.debugPort);
            let filters = dockerOpts.generateContainerNameFilter(this.containerName, true);
            let containers = yield docker.listContainers({ filters });
            if (!containers || !containers.length) {
                filters = dockerOpts.generateContainerNameFilter(this.containerName);
                containers = yield docker.listContainers({ filters });
            }
            if (containers && containers.length) {
                const jobs = [];
                for (let c of containers) {
                    const container = yield docker.getContainer(c.Id);
                    jobs.push(container.stop());
                    debug(`stopping container ${c.Id}`);
                }
                yield Promise.all(jobs);
                debug('all containers stopped');
            }
            const cmd = docker.generateDockerCmd(this.runtime, true, {
                functionProps: this.functionProps
            });
            this.opts = yield dockerOpts.generateLocalStartOpts(this.runtime, this.containerName, this.mounts, cmd, this.envs, {
                debugPort: this.debugPort,
                dockerUser: this.dockerUser,
                debugIde: this.debugIde,
                imageName: this.imageName,
                caPort: this.functionProps.CAPort
            });
            const container = yield docker.createAndRunContainer(this.opts);
            yield container.logs({
                stdout: true,
                stderr: true,
                follow: true,
                since: (new Date().getTime() / 1000)
            });
            console.log('local start succeeded.');
            yield this.showDebugIdeTips();
        });
    }
}
module.exports = EventStart;
