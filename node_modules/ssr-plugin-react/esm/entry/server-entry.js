import * as React from 'react';
import { StaticRouter } from 'react-router-dom';
import { findRoute, getManifest, logGreen, normalizePath } from 'ssr-server-utils';
// @ts-expect-error
import * as Routes from 'ssr-temporary-routes';
import { serverContext } from './create-context';
// @ts-expect-error
import Layout from '@/components/layout/index.tsx';
const { FeRoutes, layoutFetch, BASE_NAME } = Routes;
const serverRender = async (ctx, config) => {
    var _a, _b;
    const { cssOrder, jsOrder, dynamic, mode, chunkName } = config;
    global.window = (_a = global.window) !== null && _a !== void 0 ? _a : {}; // 防止覆盖上层应用自己定义的 window 对象
    let path = ctx.request.path; // 这里取 pathname 不能够包含 queyString
    if (BASE_NAME) {
        path = normalizePath(path);
    }
    const { window } = global;
    const routeItem = findRoute(FeRoutes, path);
    const ViteMode = process.env.BUILD_TOOL === 'vite';
    if (!routeItem) {
        throw new Error(`
    查找组件失败，请确认当前 path: ${path} 对应前端组件是否存在
    若创建了新的页面文件夹，请重新执行 npm start 重启服务
    `);
    }
    let dynamicCssOrder = cssOrder;
    if (dynamic) {
        dynamicCssOrder = cssOrder.concat([`${routeItem.webpackChunkName}.css`]);
    }
    const manifest = ViteMode ? {} : await getManifest();
    const injectCss = [];
    if (ViteMode) {
        injectCss.push(React.createElement("script", { src: "/@vite/client", type: "module", key: "vite-client" }));
        injectCss.push(React.createElement("script", { key: "vite-react-refresh", type: "module", dangerouslySetInnerHTML: {
                __html: ` import RefreshRuntime from "/@react-refresh"
      RefreshRuntime.injectIntoGlobalHook(window)
      window.$RefreshReg$ = () => {}
      window.$RefreshSig$ = () => (type) => type
      window.__vite_plugin_react_preamble_installed__ = true`
            } }));
        injectCss.push(React.createElement("link", { rel: 'stylesheet', href: `/server/static/css/${chunkName}.css`, key: "vite-head-css" }));
    }
    else {
        dynamicCssOrder.forEach(css => {
            if (manifest[css]) {
                const item = manifest[css];
                injectCss.push(React.createElement("link", { rel: 'stylesheet', key: item, href: item }));
            }
        });
    }
    const injectScript = ViteMode ? [
        React.createElement("script", { key: "viteWindowInit", dangerouslySetInnerHTML: {
                __html: 'window.__USE_VITE__=true'
            } }),
        React.createElement("script", { type: "module", src: '/node_modules/ssr-plugin-react/esm/entry/client-entry.js', key: "vite-react-entry" })
    ]
        : jsOrder.map(js => manifest[js]).map(item => React.createElement("script", { key: item, src: item }));
    const staticList = {
        injectCss,
        injectScript
    };
    const isCsr = !!(mode === 'csr' || ((_b = ctx.request.query) === null || _b === void 0 ? void 0 : _b.csr));
    const Component = routeItem.component;
    if (isCsr) {
        logGreen(`Current path ${path} use csr render mode`);
    }
    const layoutFetchData = (!isCsr && layoutFetch) ? await layoutFetch(ctx) : null;
    const fetchData = (!isCsr && routeItem.fetch) ? await routeItem.fetch(ctx) : null;
    const combineData = isCsr ? null : Object.assign({}, layoutFetchData !== null && layoutFetchData !== void 0 ? layoutFetchData : {}, fetchData !== null && fetchData !== void 0 ? fetchData : {});
    const Context = serverContext(combineData); // 服务端需要每个请求创建新的独立的 context
    window.STORE_CONTEXT = Context; // 为每一个新的请求都创建一遍 context 并且覆盖 window 上的属性，使得无需通过props层层传递读取
    return (React.createElement(StaticRouter, null,
        React.createElement(Context.Provider, { value: { state: combineData } },
            React.createElement(Layout, { ctx: ctx, config: config, staticList: staticList }, isCsr ? React.createElement(React.Fragment, null) : React.createElement(Component, null)))));
};
export default serverRender;
